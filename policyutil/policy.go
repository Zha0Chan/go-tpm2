// Copyright 2023 Canonical Ltd.
// Licensed under the LGPLv3 with static-linking exception.
// See LICENCE file for details.

package policyutil

import (
	"bytes"
	"crypto"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strings"
	"unicode/utf8"

	"github.com/canonical/go-tpm2"
	"github.com/canonical/go-tpm2/mu"
)

var (
	// ErrMissingDigest is returned from [Policy.Execute] when a TPM2_PolicyCpHash or
	// TPM2_PolicyNameHash assertion is missing a digest for the selected session algorithm.
	ErrMissingDigest = errors.New("missing digest for session algorithm")
)

type (
	taskFn   func() error
	paramKey [sha256.Size]byte
)

func policyParamKey(authName tpm2.Name, policyRef tpm2.Nonce) paramKey {
	h := crypto.SHA256.New()
	mu.MustMarshalToWriter(h, authName, policyRef)

	var key paramKey
	copy(key[:], h.Sum(nil))
	return key
}

// PolicyTicket corresponds to a ticket generated from a TPM2_PolicySigned or TPM2_PolicySecret
// assertion and is returned by [Policy.Execute]. Generated tickets can be supplied to
// [Policy.Execute] in the future in order to satisfy these assertions as long as they haven't
// expired.
type PolicyTicket struct {
	AuthName  tpm2.Name    // The name of the auth object associated with the corresponding assertion
	PolicyRef tpm2.Nonce   // The policy ref of the corresponding assertion
	CpHash    tpm2.Digest  // The cpHash supplied to the assertion that generated this ticket
	Timeout   tpm2.Timeout // The timeout returned by the assertion that generated this ticket

	// Ticket is the actual ticket returned by the TPM for the assertion that generated this ticket.
	// The Tag field indicates whether this was generated by TPM2_PolicySigned or TPM2_PolicySecret.
	Ticket *tpm2.TkAuth
}

// PolicyError is returned from [Policy.Execute] and other methods when an error
// is encountered during some processing of a policy. It provides an indication of
// where an error occurred.
type PolicyError struct {
	Path string // the path of the branch at which the error occurred

	task string
	err  error
}

func (e *PolicyError) Error() string {
	branch := "root branch"
	if len(e.Path) > 0 {
		branch = "branch " + e.Path
	}
	return fmt.Sprintf("cannot run '%s' task in %s: %v", e.task, branch, e.err)
}

func (e *PolicyError) Unwrap() error {
	return e.err
}

// SubPolicyError is returned from [Policy.Execute] if an error is encountered during
// the execution of a sub-policy. This should be wrapped in either a [PolicyNVError]
// or [PolicyAuthorizationError] which indicates the resource that the error occurred for.
type SubPolicyError struct {
	err error
}

func (e *SubPolicyError) Error() string {
	return fmt.Sprintf("encountered an error when running sub-policy for resource: %v", e.err)
}

func (e *SubPolicyError) Unwrap() error {
	return e.err
}

// PolicyNVError is returned from [Policy.Execute] and other methods when an error
// is encountered with a NV index.
type PolicyNVError struct {
	Index tpm2.Handle // The NV index handle
	Name  tpm2.Name   // The NV index name

	err error
}

func (e *PolicyNVError) Error() string {
	return fmt.Sprintf("cannot complete assertion with NV index %v (name: %#x): %v", e.Index, e.Name, e.err)
}

func (e *PolicyNVError) Unwrap() error {
	return e.err
}

// PolicyAuthorizationError is returned from [Policy.Execute] if:
//   - the policy uses TPM2_PolicySecret and the associated object could not be authorized.
//   - the policy uses TPM2_PolicySigned and no or an invalid signed authorization was supplied.
//   - the policy uses TPM2_PolicyAuthorize and no or an invalid authorized policy was supplied.
type PolicyAuthorizationError struct {
	AuthName  tpm2.Name
	PolicyRef tpm2.Nonce
	err       error
}

func (e *PolicyAuthorizationError) Error() string {
	return fmt.Sprintf("cannot complete authorization with authName=%#x, policyRef=%#x: %v", e.AuthName, e.PolicyRef, e.err)
}

func (e *PolicyAuthorizationError) Unwrap() error {
	return e.err
}

// ResourceLoadError is returned from [Policy.Execute] if the policy required a resource that
// could not be loaded.
type ResourceLoadError struct {
	Name tpm2.Name
	err  error
}

func (e *ResourceLoadError) Error() string {
	return fmt.Sprintf("cannot load resource with name %#x: %v", e.Name, e.err)
}

func (e *ResourceLoadError) Unwrap() error {
	return e.err
}

type policyBranchName string

func (n policyBranchName) isValid() bool {
	if !utf8.ValidString(string(n)) {
		return false
	}
	if (len(n) > 0 && (n[0] == '$' || n[0] == '*')) || strings.HasPrefix(string(n), "â€¦") {
		return false
	}
	return true
}

func (n policyBranchName) Marshal(w io.Writer) error {
	if !n.isValid() {
		return errors.New("invalid name")
	}
	_, err := mu.MarshalToWriter(w, []byte(n))
	return err
}

func (n *policyBranchName) Unmarshal(r io.Reader) error {
	var b []byte
	if _, err := mu.UnmarshalFromReader(r, &b); err != nil {
		return err
	}
	name := policyBranchName(b)
	if !name.isValid() {
		return errors.New("invalid name")
	}
	*n = name
	return nil
}

type policyBranchPath string

func (p policyBranchPath) PopNextComponent() (next policyBranchPath, remaining policyBranchPath) {
	remaining = p
	for len(remaining) > 0 {
		s := strings.SplitN(string(remaining), "/", 2)
		remaining = ""
		if len(s) == 2 {
			remaining = policyBranchPath(s[1])
		}
		component := policyBranchPath(s[0])
		if len(component) > 0 {
			return component, remaining
		}
	}

	return "", ""
}

func (p policyBranchPath) Concat(path policyBranchPath) policyBranchPath {
	var pathElements []string
	if p != "" {
		pathElements = append(pathElements, string(p))
	}
	if path != "" {
		pathElements = append(pathElements, string(path))
	}
	return policyBranchPath(strings.Join(pathElements, "/"))
}

// PolicySessionUsage describes how a policy session will be used, and assists with
// automatically selecting branches where a policy has command context-specific branches.
type PolicySessionUsage struct {
	commandCode tpm2.CommandCode
	handles     []Named
	params      []interface{}
	nvHandle    tpm2.Handle
	noAuthValue bool
}

// NewPolicySessionUsage creates a new PolicySessionUsage.
func NewPolicySessionUsage(command tpm2.CommandCode, handles []Named, params ...interface{}) *PolicySessionUsage {
	return &PolicySessionUsage{
		commandCode: command,
		handles:     handles,
		params:      params,
	}
}

// WithNVHandle indicates that the policy session is being used to authorize a NV
// index with the specified handle. This will panic if handle is not a NV index.
func (u *PolicySessionUsage) WithNVHandle(handle tpm2.Handle) *PolicySessionUsage {
	if handle.Type() != tpm2.HandleTypeNVIndex {
		panic("invalid handle")
	}
	u.nvHandle = handle
	return u
}

// NoAuthValue indicates that the policy session is being used to authorize a
// resource that the authorization value cannot be determined for.
func (u *PolicySessionUsage) NoAuthValue() *PolicySessionUsage {
	u.noAuthValue = true
	return u
}

type PolicyAuthorizationID = PolicyAuthorizationDetails

// PolicyExecuteParams contains parameters that are useful for executing a policy.
type PolicyExecuteParams struct {
	Tickets []*PolicyTicket // Tickets for TPM2_PolicySecret and TPM2_PolicySigned assertions

	// Usage describes how the executed policy will be used, and assists with
	// automatically selecting branches where a policy has command context-specific
	// branches.
	Usage *PolicySessionUsage

	// Path provides a way to explicitly select branches or authorized policies to
	// execute. A path consists of zero or more components separated by a '/'
	// character, with each component identifying a branch to select when a branch
	// node is encountered (or a policy to select when an authorized policy is
	// required) during execution. When a branch node or authorized policy is
	// encountered, the selected sub-branch or policy is executed before resuming
	// execution in the original branch.
	//
	// When selecting a branch, a component can either identify a branch by its
	// name (if it has one), or it can be a numeric identifier of the form "$[n]"
	// which selects the branch at index n.
	//
	// When selecting an authorized policy, a component identifies the policy by
	// specifying the digest of the policy for the current session algorithm.
	//
	// If a component is "**", then Policy.Execute will attempt to automatically
	// select an execution path for the entire sub-tree associated with the current
	// branch node or authorized policy. This includes choosing additional
	// branches and authorized policies encountered during the execution of the
	// selected sub-tree. Remaining path components will be consumed when resuming
	// execution in the original branch
	//
	// If a component is "*", then Policy.Execute will attempt to automatically
	// select an immediate sub-branch or authorized policy, but additional branches
	// and authorized policies encountered during the execution of the selected
	// sub-tree will consume additional path components.
	//
	// If the path has insufficent components for the branch nodes or authorized policies
	// encountered in a policy, Policy.Execute will attempt to select an appropriate
	// execution path for the remainder of the policy automatically.
	Path string

	// IgnoreAuthorizations can be used to indicate that branches containing TPM2_PolicySigned,
	// TPM2_PolicySecret or TPM2_PolicyAuthorize assertions matching the specified ID should
	// be ignored. This can be used where these assertions have failed on previous runs.
	// This propagates to sub-policies.
	IgnoreAuthorizations []PolicyAuthorizationID

	// IgnoreNV can be used to indicate that branches containing TPM2_PolicyNV assertions
	// with an NV index matching the specified name should be ignored. This can be used where
	// these assertions have failed due to an authorization issue on previous runs. This
	// propagates to sub-policies.
	IgnoreNV []Named
}

type policyTickets interface {
	ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket
	addTicket(ticket *PolicyTicket)
	removeTicket(ticket *PolicyTicket)
}

type policyRunnerHelper interface {
	loadExternal(public *tpm2.Public) (ResourceContext, error)
	cpHash(cpHash *policyCpHashElement) error
	nameHash(nameHash *policyNameHashElement) error
	authorize(auth tpm2.ResourceContext, policy *Policy, usage *PolicySessionUsage, prefer tpm2.SessionType, complete func(error, tpm2.SessionContext) error) error
	handleBranches(branches policyBranches, complete func(tpm2.DigestList, int) error) error
	handleAuthorizedPolicy(keySign *tpm2.Public, policyRef tpm2.Nonce, policies []*Policy, complete func(tpm2.Digest, *tpm2.TkVerified) error) error
}

type policySessionContext interface {
	session() policySession
	tickets() policyTickets
	resources() PolicyResourceLoader
	helper() policyRunnerHelper
}

type policyRunnerController interface {
	currentTaskName() string

	currentPath() policyBranchPath
	setCurrentPath(path policyBranchPath) (restore func())

	pushTasks(fns ...taskFn)
	pushElements(elements policyElements)
	appendTask(fn taskFn)

	snapshotTasks() (restore func(), n int)
	clearTasks()

	session() policySession
	setSession(session policySession) (restore func())
}

type taggedHash struct {
	HashAlg tpm2.HashAlgorithmId
	Digest  tpm2.Digest
}

func (h taggedHash) Marshal(w io.Writer) error {
	ta := tpm2.MakeTaggedHash(h.HashAlg, h.Digest)
	_, err := mu.MarshalToWriter(w, ta)
	return err
}

func (h *taggedHash) Unmarshal(r io.Reader) error {
	var ta tpm2.TaggedHash
	if _, err := mu.UnmarshalFromReader(r, &ta); err != nil {
		return err
	}

	if ta.HashAlg != tpm2.HashAlgorithmNull && !ta.HashAlg.IsValid() {
		return errors.New("invalid digest algorithm")
	}

	*h = taggedHash{
		HashAlg: ta.HashAlg,
		Digest:  ta.Digest()}
	return nil
}

type taggedHashList []taggedHash

type policyNVElement struct {
	NvIndex   *tpm2.NVPublic
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (*policyNVElement) name() string { return "TPM2_PolicyNV assertion" }

func (e *policyNVElement) run(context policySessionContext) (err error) {
	nvIndex, policy, err := context.resources().LoadNV(e.NvIndex)
	if err != nil {
		return fmt.Errorf("cannot create nvIndex context: %w", err)
	}

	var auth ResourceContext = newResourceContextFlushable(nvIndex, nil)
	switch {
	case e.NvIndex.Attrs&tpm2.AttrNVPolicyRead != 0:
		// use NV index for auth
	case e.NvIndex.Attrs&tpm2.AttrNVAuthRead != 0:
		// use NV index for auth
	case e.NvIndex.Attrs&tpm2.AttrNVOwnerRead != 0:
		auth, policy, err = context.resources().LoadName(tpm2.MakeHandleName(tpm2.HandleOwner))
	case e.NvIndex.Attrs&tpm2.AttrNVPPRead != 0:
		auth, policy, err = context.resources().LoadName(tpm2.MakeHandleName(tpm2.HandlePlatform))
	default:
		return errors.New("invalid nvIndex read auth mode")
	}
	if err != nil {
		return fmt.Errorf("cannot create auth context: %w", err)
	}

	usage := NewPolicySessionUsage(
		tpm2.CommandPolicyNV,
		[]Named{auth.Resource(), nvIndex, context.session().Name()},
		e.OperandB, e.Offset, e.Operation,
	)

	restore, err := context.session().Save()
	if err != nil {
		return fmt.Errorf("cannot save session: %w", err)
	}
	defer func() {
		if err == nil {
			return
		}
		restore()
	}()

	if err := context.helper().authorize(auth.Resource(), policy, usage, tpm2.SessionTypePolicy, func(sessionErr error, session tpm2.SessionContext) error {
		if err := restore(); err != nil {
			return fmt.Errorf("cannot restore session: %w", err)
		}
		if sessionErr != nil {
			return &PolicyNVError{Index: nvIndex.Handle(), Name: nvIndex.Name(), err: sessionErr}
		}
		if err := context.session().PolicyNV(auth.Resource(), nvIndex, e.OperandB, e.Offset, e.Operation, session); err != nil {
			return &PolicyNVError{Index: nvIndex.Handle(), Name: nvIndex.Name(), err: err}
		}
		return nil
	}); err != nil {
		return &PolicyNVError{Index: nvIndex.Handle(), Name: nvIndex.Name(), err: err}
	}

	return nil
}

type policySecretElement struct {
	AuthObjectName tpm2.Name
	PolicyRef      tpm2.Nonce
}

func (*policySecretElement) name() string { return "TPM2_PolicySecret assertion" }

func (e *policySecretElement) run(context policySessionContext) (err error) {
	if ticket := context.tickets().ticket(e.AuthObjectName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySecret
			context.tickets().removeTicket(ticket)
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySecret
			context.tickets().removeTicket(ticket)
		case err != nil:
			return &PolicyAuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: err}
		default:
			// The ticket was accepted
			return nil
		}
	}

	// LoadName can create additional sessions, so save the current one now.
	restore, err := context.session().Save()
	if err != nil {
		return fmt.Errorf("cannot save session: %w", err)
	}
	defer func() {
		if err == nil {
			return
		}
		restore()
	}()

	authObject, policy, err := context.resources().LoadName(e.AuthObjectName)
	if err != nil {
		return &ResourceLoadError{Name: e.AuthObjectName, err: err}
	}

	flushAuthObject := func() {
		if authObject.Resource().Handle().Type() != tpm2.HandleTypeTransient {
			return
		}
		authObject.Flush()
	}
	defer func() {
		if err == nil {
			return
		}
		flushAuthObject()
	}()

	usage := NewPolicySessionUsage(
		tpm2.CommandPolicySecret,
		[]Named{authObject.Resource(), context.session().Name()},
		tpm2.Digest{}, e.PolicyRef, int32(0),
	)

	if err := context.helper().authorize(authObject.Resource(), policy, usage, tpm2.SessionTypeHMAC, func(sessionErr error, session tpm2.SessionContext) error {
		defer flushAuthObject()

		if err := restore(); err != nil {
			return fmt.Errorf("cannot restore session: %w", err)
		}

		if sessionErr != nil {
			return &PolicyAuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: sessionErr}
		}

		timeout, ticket, err := context.session().PolicySecret(authObject.Resource(), nil, e.PolicyRef, 0, session)
		if err != nil {
			return &PolicyAuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: err}
		}

		context.tickets().addTicket(&PolicyTicket{
			AuthName:  e.AuthObjectName,
			PolicyRef: e.PolicyRef,
			CpHash:    nil,
			Timeout:   timeout,
			Ticket:    ticket})
		return nil
	}); err != nil {
		return &PolicyAuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: err}
	}

	return nil
}

type policySignedElement struct {
	AuthKey   *tpm2.Public
	PolicyRef tpm2.Nonce
}

func (*policySignedElement) name() string { return "TPM2_PolicySigned assertion" }

func (e *policySignedElement) run(context policySessionContext) error {
	authKeyName := e.AuthKey.Name()
	if !authKeyName.IsValid() {
		return errors.New("invalid auth key name")
	}

	if ticket := context.tickets().ticket(authKeyName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySigned
			context.tickets().removeTicket(ticket)
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySigned
			context.tickets().removeTicket(ticket)
		case err != nil:
			return &PolicyAuthorizationError{AuthName: authKeyName, PolicyRef: e.PolicyRef, err: err}
		default:
			// The ticket was accepted
			return nil
		}
	}

	auth, err := context.resources().SignAuthorization(context.session().NonceTPM(), authKeyName, e.PolicyRef)
	if err != nil {
		return &PolicyAuthorizationError{
			AuthName:  authKeyName,
			PolicyRef: e.PolicyRef,
			err:       fmt.Errorf("cannot obtain signed authorization: %w", err),
		}
	}

	authKey, err := context.helper().loadExternal(e.AuthKey)
	if err != nil {
		return fmt.Errorf("cannot create authKey context: %w", err)
	}
	defer authKey.Flush()

	includeNonceTPM := false
	if len(auth.NonceTPM) > 0 {
		includeNonceTPM = true
	}

	timeout, ticket, err := context.session().PolicySigned(authKey.Resource(), includeNonceTPM, auth.CpHash, e.PolicyRef, auth.Expiration, auth.Authorization.Signature)
	if err != nil {
		return &PolicyAuthorizationError{AuthName: authKeyName, PolicyRef: e.PolicyRef, err: err}
	}

	context.tickets().addTicket(&PolicyTicket{
		AuthName:  authKeyName,
		PolicyRef: e.PolicyRef,
		CpHash:    auth.CpHash,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policyAuthorizations []PolicyAuthorization

type policyAuthorizeElement struct {
	PolicyRef tpm2.Nonce
	KeySign   *tpm2.Public
}

func (*policyAuthorizeElement) name() string { return "authorized policy" }

func (e *policyAuthorizeElement) run(context policySessionContext) error {
	keySignName := e.KeySign.Name()
	if !keySignName.IsValid() {
		return errors.New("invalid keySign")
	}

	policies, err := context.resources().LoadAuthorizedPolicies(keySignName, e.PolicyRef)
	if err != nil {
		return &PolicyAuthorizationError{AuthName: keySignName, PolicyRef: e.PolicyRef, err: err}
	}
	if err := context.helper().handleAuthorizedPolicy(e.KeySign, e.PolicyRef, policies, func(approvedPolicy tpm2.Digest, checkTicket *tpm2.TkVerified) error {
		return context.session().PolicyAuthorize(approvedPolicy, e.PolicyRef, keySignName, checkTicket)
	}); err != nil {
		return &PolicyAuthorizationError{AuthName: keySignName, PolicyRef: e.PolicyRef, err: err}
	}
	return nil
}

type policyAuthValueElement struct{}

func (*policyAuthValueElement) name() string { return "TPM2_PolicyAuthValue assertion" }

func (*policyAuthValueElement) run(context policySessionContext) error {
	return context.session().PolicyAuthValue()
}

type policyCommandCodeElement struct {
	CommandCode tpm2.CommandCode
}

func (*policyCommandCodeElement) name() string { return "TPM2_PolicyCommandCode assertion" }

func (e *policyCommandCodeElement) run(context policySessionContext) error {
	return context.session().PolicyCommandCode(e.CommandCode)
}

type policyCounterTimerElement struct {
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (*policyCounterTimerElement) name() string { return "TPM2_PolicyCounterTimer assertion" }

func (e *policyCounterTimerElement) run(context policySessionContext) error {
	return context.session().PolicyCounterTimer(e.OperandB, e.Offset, e.Operation)
}

type policyCpHashElement struct {
	CommandCode tpm2.CommandCode
	Handles     []tpm2.Name
	CpBytes     []byte

	Digest tpm2.Digest
}

func (*policyCpHashElement) name() string { return "TPM2_PolicyCpHash assertion" }

func (e *policyCpHashElement) run(context policySessionContext) error {
	if err := context.helper().cpHash(e); err != nil {
		return err
	}
	return context.session().PolicyCpHash(e.Digest)
}

type policyNameHashElement struct {
	Handles []tpm2.Name

	Digest tpm2.Digest
}

func (*policyNameHashElement) name() string { return "TPM2_PolicyNameHash assertion" }

func (e *policyNameHashElement) run(context policySessionContext) error {
	if err := context.helper().nameHash(e); err != nil {
		return err
	}
	return context.session().PolicyNameHash(e.Digest)
}

type policyBranch struct {
	Name          policyBranchName
	PolicyDigests taggedHashList
	Policy        policyElements
}

type policyBranches []*policyBranch

type policyORElement struct {
	Branches policyBranches
}

func (*policyORElement) name() string { return "branch node" }

func (e *policyORElement) run(context policySessionContext) error {
	return context.helper().handleBranches(e.Branches, func(digests tpm2.DigestList, selected int) error {
		tree, err := newPolicyOrTree(context.session().HashAlg(), digests)
		if err != nil {
			return fmt.Errorf("cannot compute PolicyOR tree: %w", err)
		}

		pHashLists := tree.selectBranch(selected)

		for _, pHashList := range pHashLists {
			if err := context.session().PolicyOR(pHashList); err != nil {
				return err
			}
		}
		return nil
	})
}

type pcrValue struct {
	PCR    tpm2.Handle
	Digest taggedHash
}

type pcrValueList []pcrValue

type policyPCRElement struct {
	PCRs pcrValueList
}

func (*policyPCRElement) name() string { return "TPM2_PolicyPCR assertion" }

func (e *policyPCRElement) run(context policySessionContext) error {
	values, err := e.pcrValues()
	if err != nil {
		return err
	}
	pcrs, pcrDigest, err := ComputePCRDigestFromAllValues(context.session().HashAlg(), values)
	if err != nil {
		return fmt.Errorf("cannot compute PCR digest: %w", err)
	}
	return context.session().PolicyPCR(pcrDigest, pcrs)
}

func (e *policyPCRElement) pcrValues() (tpm2.PCRValues, error) {
	values := make(tpm2.PCRValues)
	for i, value := range e.PCRs {
		if value.PCR.Type() != tpm2.HandleTypePCR {
			return nil, fmt.Errorf("invalid PCR handle at index %d", i)
		}
		if err := values.SetValue(value.Digest.HashAlg, int(value.PCR), value.Digest.Digest); err != nil {
			return nil, fmt.Errorf("invalid PCR value at index %d: %w", i, err)
		}
	}
	return values, nil
}

type policyDuplicationSelectElement struct {
	Object        tpm2.Name
	NewParent     tpm2.Name
	IncludeObject bool
}

func (*policyDuplicationSelectElement) name() string { return "TPM2_PolicyDuplicationSelect assertion" }

func (e *policyDuplicationSelectElement) run(context policySessionContext) error {
	return context.session().PolicyDuplicationSelect(e.Object, e.NewParent, e.IncludeObject)
}

type policyPasswordElement struct{}

func (*policyPasswordElement) name() string { return "TPM2_PolicyPassword assertion" }

func (*policyPasswordElement) run(context policySessionContext) error {
	return context.session().PolicyPassword()
}

type policyNvWrittenElement struct {
	WrittenSet bool
}

func (*policyNvWrittenElement) name() string { return "TPM2_PolicyNvWritten assertion" }

func (e *policyNvWrittenElement) run(context policySessionContext) error {
	return context.session().PolicyNvWritten(e.WrittenSet)
}

type policyElementDetails struct {
	NV                *policyNVElement
	Secret            *policySecretElement
	Signed            *policySignedElement
	Authorize         *policyAuthorizeElement
	AuthValue         *policyAuthValueElement
	CommandCode       *policyCommandCodeElement
	CounterTimer      *policyCounterTimerElement
	CpHash            *policyCpHashElement
	NameHash          *policyNameHashElement
	OR                *policyORElement
	PCR               *policyPCRElement
	DuplicationSelect *policyDuplicationSelectElement
	Password          *policyPasswordElement
	NvWritten         *policyNvWrittenElement
}

func (d *policyElementDetails) Select(selector reflect.Value) interface{} {
	switch selector.Interface().(tpm2.CommandCode) {
	case tpm2.CommandPolicyNV:
		return &d.NV
	case tpm2.CommandPolicySecret:
		return &d.Secret
	case tpm2.CommandPolicySigned:
		return &d.Signed
	case tpm2.CommandPolicyAuthorize:
		return &d.Authorize
	case tpm2.CommandPolicyAuthValue:
		return &d.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return &d.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return &d.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return &d.CpHash
	case tpm2.CommandPolicyNameHash:
		return &d.NameHash
	case tpm2.CommandPolicyOR:
		return &d.OR
	case tpm2.CommandPolicyPCR:
		return &d.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return &d.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return &d.Password
	case tpm2.CommandPolicyNvWritten:
		return &d.NvWritten
	default:
		return nil
	}
}

type policyElementRunner interface {
	name() string
	run(context policySessionContext) error
}

type policyElement struct {
	Type    tpm2.CommandCode
	Details *policyElementDetails
}

func (e *policyElement) runner() policyElementRunner {
	switch e.Type {
	case tpm2.CommandPolicyNV:
		return e.Details.NV
	case tpm2.CommandPolicySecret:
		return e.Details.Secret
	case tpm2.CommandPolicySigned:
		return e.Details.Signed
	case tpm2.CommandPolicyAuthorize:
		return e.Details.Authorize
	case tpm2.CommandPolicyAuthValue:
		return e.Details.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return e.Details.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return e.Details.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return e.Details.CpHash
	case tpm2.CommandPolicyNameHash:
		return e.Details.NameHash
	case tpm2.CommandPolicyOR:
		return e.Details.OR
	case tpm2.CommandPolicyPCR:
		return e.Details.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return e.Details.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return e.Details.Password
	case tpm2.CommandPolicyNvWritten:
		return e.Details.NvWritten
	default:
		panic("invalid type")
	}
}

type policyElements []*policyElement

type policy struct {
	PolicyDigests        taggedHashList
	PolicyAuthorizations policyAuthorizations
	Policy               policyElements
}

// Policy corresponds to an authorization policy. It can be serialized with
// [github.com/canonical/go-tpm2/mu].
type Policy struct {
	policy policy
}

// Marshal implements [mu.CustomMarshaller.Marshal].
func (p Policy) Marshal(w io.Writer) error {
	_, err := mu.MarshalToWriter(w, p.policy)
	return err
}

// Unmarshal implements [mu.CustomMarshaller.Unarshal].
func (p *Policy) Unmarshal(r io.Reader) error {
	_, err := mu.UnmarshalFromReader(r, &p.policy)
	return err
}

type policyTask struct {
	name string
	fn   taskFn
}

func newElementPolicyTask(context policySessionContext, element *policyElement) *policyTask {
	runner := element.runner()
	return &policyTask{
		name: runner.name(),
		fn: func() error {
			return runner.run(context)
		},
	}
}

func newDeferredPolicyTask(controller policyRunnerController, fn taskFn) *policyTask {
	return &policyTask{
		name: controller.currentTaskName(),
		fn:   fn,
	}
}

type policyRunner struct {
	policySession      policySession
	policyTickets      policyTickets
	policyResources    PolicyResourceLoader
	policyRunnerHelper policyRunnerHelper

	policyCurrentTaskName string
	policyCurrentPath     policyBranchPath

	tasks []*policyTask

	err error
}

func newPolicyRunner(session policySession, tickets policyTickets, resources PolicyResourceLoader, newHelperFn func(*policyRunner) policyRunnerHelper) *policyRunner {
	out := &policyRunner{
		policySession:   session,
		policyTickets:   tickets,
		policyResources: resources,
	}
	out.policyRunnerHelper = newHelperFn(out)
	return out
}

func (r *policyRunner) session() policySession {
	return r.policySession
}

func (r *policyRunner) tickets() policyTickets {
	return r.policyTickets
}

func (r *policyRunner) resources() PolicyResourceLoader {
	return r.policyResources
}

func (r *policyRunner) helper() policyRunnerHelper {
	return r.policyRunnerHelper
}

func (r *policyRunner) currentTaskName() string {
	return r.policyCurrentTaskName
}

func (r *policyRunner) currentPath() policyBranchPath {
	return r.policyCurrentPath
}

func (r *policyRunner) setCurrentPath(path policyBranchPath) (restore func()) {
	orig := r.policyCurrentPath
	r.policyCurrentPath = path
	return func() {
		r.policyCurrentPath = orig
	}
}

func (r *policyRunner) pushTasks(fns ...taskFn) {
	var tasks []*policyTask
	for _, fn := range fns {
		tasks = append(tasks, newDeferredPolicyTask(r, fn))
	}
	r.tasks = append(tasks, r.tasks...)
}

func (r *policyRunner) pushElements(elements policyElements) {
	var tasks []*policyTask
	for _, element := range elements {
		tasks = append(tasks, newElementPolicyTask(r, element))
	}
	r.tasks = append(tasks, r.tasks...)
}

func (r *policyRunner) appendTask(fn taskFn) {
	r.tasks = append(r.tasks, newDeferredPolicyTask(r, fn))
}

func (r *policyRunner) snapshotTasks() (restore func(), n int) {
	tasks := r.tasks
	return func() {
		r.tasks = tasks
	}, len(tasks)
}

func (r *policyRunner) clearTasks() {
	r.tasks = nil
}

func (r *policyRunner) setSession(session policySession) (restore func()) {
	orig := r.policySession
	r.policySession = session
	return func() {
		r.policySession = orig
	}
}

func (r *policyRunner) more() bool {
	return len(r.tasks) > 0
}

func (r *policyRunner) runNextTask() {
	task := r.tasks[0]
	r.tasks = r.tasks[1:]
	r.policyCurrentTaskName = task.name
	if err := task.fn(); err != nil {
		r.err = &PolicyError{Path: string(r.policyCurrentPath), task: r.policyCurrentTaskName, err: err}
	}
}

func (r *policyRunner) run(policy policyElements) error {
	r.pushElements(policy)

	for r.more() {
		r.runNextTask()
		if r.err != nil {
			return r.err
		}
	}

	return nil
}

type subPolicyContext struct {
	runner     *policyRunner
	notifyDone func()
}

type policyExecutor struct {
	runners []*subPolicyContext
	err     error
}

func (r *policyExecutor) pushRunner(runner *policyRunner, callback func(error) error) {
	// push a task to the original runner to run the callback
	r.top().runner.pushTasks(func() error {
		return callback(runner.err)
	})

	context := &subPolicyContext{
		runner: runner,
		notifyDone: func() {
			if runner != r.top().runner {
				panic("unexpected top")
			}
			r.runners = r.runners[1:]
		},
	}

	// ensure the sub-policy runs next
	r.runners = append([]*subPolicyContext{context}, r.runners...)

	// append a task that pops this runner once the policy has completed
	runner.appendTask(func() error {
		context.notifyDone()
		return nil
	})
}

func (r *policyExecutor) top() *subPolicyContext {
	return r.runners[0]
}

func (r *policyExecutor) more() bool {
	return r.top().runner.more()
}

func (r *policyExecutor) runNextTask() {
	top := r.top()
	top.runner.runNextTask()
	if top.runner.err != nil {
		top.notifyDone()
	}
}

func (r *policyExecutor) run(runner *policyRunner, policy policyElements) error {
	runner.pushElements(policy)
	r.runners = []*subPolicyContext{
		{
			runner:     runner,
			notifyDone: func() { r.err = runner.err },
		},
	}

	for r.more() {
		r.runNextTask()
		if r.err != nil {
			return r.err
		}
	}

	return nil
}

type executePolicyTickets map[paramKey]*PolicyTicket

func makeExecutePolicyTickets() executePolicyTickets {
	return make(executePolicyTickets)
}

func (t executePolicyTickets) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	return t[policyParamKey(authName, policyRef)]
}

func (t executePolicyTickets) addTicket(ticket *PolicyTicket) {
	if ticket.Ticket == nil || (ticket.Ticket.Hierarchy == tpm2.HandleNull && len(ticket.Ticket.Digest) == 0) {
		// skip null tickets
		return
	}
	t[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
}

func (t executePolicyTickets) removeTicket(ticket *PolicyTicket) {
	delete(t, policyParamKey(ticket.AuthName, ticket.PolicyRef))
}

type subPolicyRunner interface {
	pushRunner(runner *policyRunner, callback func(error) error)
}

type executePolicyHelper struct {
	policyBranchSelectMixin
	sessionAlg           tpm2.HashAlgorithmId
	tickets              policyTickets
	resources            PolicyResourceLoader
	controller           policyRunnerController
	tpm                  TPMConnection
	remaining            policyBranchPath
	usage                *PolicySessionUsage
	ignoreAuthorizations []PolicyAuthorizationID
	ignoreNV             []Named
	subPolicyRunner      subPolicyRunner
	hasResources         bool
}

func newExecutePolicyHelper(runner *policyRunner, tpm TPMConnection, params *PolicyExecuteParams, subPolicyRunner subPolicyRunner, hasResources bool) *executePolicyHelper {
	return &executePolicyHelper{
		sessionAlg:           runner.session().HashAlg(),
		tickets:              runner.tickets(),
		resources:            runner.resources(),
		controller:           runner,
		tpm:                  tpm,
		remaining:            policyBranchPath(params.Path),
		usage:                params.Usage,
		ignoreAuthorizations: params.IgnoreAuthorizations,
		ignoreNV:             params.IgnoreNV,
		subPolicyRunner:      subPolicyRunner,
		hasResources:         hasResources,
	}
}

func (h *executePolicyHelper) loadExternal(public *tpm2.Public) (ResourceContext, error) {
	resource, err := h.tpm.LoadExternal(nil, public, tpm2.HandleOwner)
	if err != nil {
		return nil, err
	}
	return newResourceContextFlushable(resource, h.tpm.FlushContext), nil
}

func (h *executePolicyHelper) cpHash(cpHash *policyCpHashElement) error {
	return nil
}

func (h *executePolicyHelper) nameHash(nameHash *policyNameHashElement) error {
	return nil
}

func (h *executePolicyHelper) authorize(auth tpm2.ResourceContext, policy *Policy, usage *PolicySessionUsage, prefer tpm2.SessionType, complete func(error, tpm2.SessionContext) error) (err error) {
	sessionType := prefer
	alg := auth.Name().Algorithm()

	switch auth.Handle().Type() {
	case tpm2.HandleTypeNVIndex:
		pub, err := h.tpm.NVReadPublic(auth)
		if err != nil {
			return fmt.Errorf("cannot obtain NVPublic: %w", err)
		}
		switch {
		case pub.Attrs&(tpm2.AttrNVAuthRead|tpm2.AttrNVPolicyRead) == tpm2.AttrNVAuthRead:
			sessionType = tpm2.SessionTypeHMAC
		case pub.Attrs&(tpm2.AttrNVAuthRead|tpm2.AttrNVPolicyRead) == tpm2.AttrNVPolicyRead:
			sessionType = tpm2.SessionTypePolicy
		}
	case tpm2.HandleTypePermanent:
		// auth value is always available
		sessionType = tpm2.SessionTypeHMAC
		alg = h.sessionAlg
	case tpm2.HandleTypeTransient, tpm2.HandleTypePersistent:
		pub, err := h.tpm.ReadPublic(auth)
		if err != nil {
			return fmt.Errorf("cannot obtain Public: %w", err)
		}
		if pub.Attrs&tpm2.AttrUserWithAuth == 0 {
			sessionType = tpm2.SessionTypePolicy
		}
	default:
		return errors.New("unexpected handle type")
	}

	if policy == nil {
		sessionType = tpm2.SessionTypeHMAC
	}

	session, err := h.tpm.StartAuthSession(sessionType, alg)
	if err != nil {
		return fmt.Errorf("cannot create session to authorize auth object: %w", err)
	}
	defer func() {
		if err == nil {
			return
		}
		h.tpm.FlushContext(session)
	}()

	if sessionType == tpm2.SessionTypePolicy {
		if policy == nil {
			return errors.New("no policy")
		}

		var details PolicyBranchDetails
		params := &PolicyExecuteParams{
			Usage:                usage,
			IgnoreAuthorizations: h.ignoreAuthorizations,
			IgnoreNV:             h.ignoreNV,
		}

		runner := newPolicyRunner(
			newProxyPolicySession(newTpmPolicySession(h.tpm, session), &details),
			h.tickets,
			h.resources,
			func(runner *policyRunner) policyRunnerHelper {
				return newExecutePolicyHelper(runner, h.tpm, params, h.subPolicyRunner, h.hasResources)
			})
		runner.pushElements(policy.policy.Policy)

		h.subPolicyRunner.pushRunner(
			runner,
			func(err error) error {
				defer h.tpm.FlushContext(session)
				if err != nil {
					return complete(&SubPolicyError{err: err}, nil)
				}

				if details.AuthValueNeeded {
					if err := h.resources.Authorize(auth); err != nil {
						return fmt.Errorf("cannot authorize resource: %w", err)
					}
				}
				return complete(nil, session)
			},
		)
		return nil
	}

	if err := h.resources.Authorize(auth); err != nil {
		return fmt.Errorf("cannot authorize resource: %w", err)
	}

	h.controller.pushTasks(func() error {
		defer h.tpm.FlushContext(session)
		return complete(nil, session)
	})
	return nil
}

func (h *executePolicyHelper) handleBranches(branches policyBranches, complete func(tpm2.DigestList, int) error) error {
	if len(branches) == 0 {
		return errors.New("no branches")
	}

	next, remaining := h.remaining.PopNextComponent()
	if len(next) == 0 || next[0] == '*' {
		// There are no more components or the next component is a wildcard match - build a
		// list of candidate paths for this subtree
		resources := h.resources
		if !h.hasResources {
			resources = nil
		}
		selector := newPolicyBranchSelector(h.sessionAlg, resources, h.controller, h.subPolicyRunner, h.tpm, h.usage, h.ignoreAuthorizations, h.ignoreNV)
		if err := selector.selectPath(branches, func(path policyBranchPath) error {
			switch next {
			case "":
				// We have a path for this whole subtree
				h.remaining = path
			case "**":
				// Prepend the path for this whole subtree to the remaining components
				h.remaining = path.Concat(remaining)
			case "*":
				// Prepend the first component of the path for this subtree to the remaining components
				component, _ := path.PopNextComponent()
				h.remaining = component.Concat(remaining)
			default:
				panic("not reached")
			}

			// rerun branch node
			h.controller.pushElements(policyElements{&policyElement{
				Type: tpm2.CommandPolicyOR,
				Details: &policyElementDetails{
					OR: &policyORElement{Branches: branches}}}})
			return nil
		}); err != nil {
			return fmt.Errorf("cannot filter inappropriate branches: %w", err)
		}
		return nil
	}

	// We have a branch selector
	h.remaining = remaining
	selected, err := h.selectBranch(branches, next)
	if err != nil {
		return err
	}

	// Obtain the branch digests
	var digests tpm2.DigestList
	for _, branch := range branches {
		found := false
		for _, digest := range branch.PolicyDigests {
			if digest.HashAlg != h.sessionAlg {
				continue
			}

			digests = append(digests, digest.Digest)
			found = true
			break
		}
		if !found {
			return ErrMissingDigest
		}
	}

	// Run it!
	h.controller.pushTasks(func() error {
		if err := complete(digests, selected); err != nil {
			return fmt.Errorf("cannot complete: %w", err)
		}
		return nil
	})
	h.controller.pushElements(branches[selected].Policy)
	h.controller.setCurrentPath(h.controller.currentPath().Concat(next))

	return nil
}

func (h *executePolicyHelper) handleAuthorizedPolicy(keySign *tpm2.Public, policyRef tpm2.Nonce, policies []*Policy, complete func(tpm2.Digest, *tpm2.TkVerified) error) error {
	// Filter out policies that aren't computed for the current session algorithm.
	var candidatePolicies []*Policy
	var branches policyBranches
	for _, policy := range policies {
		for _, digest := range policy.policy.PolicyDigests {
			if digest.HashAlg != h.sessionAlg {
				continue
			}

			candidatePolicies = append(candidatePolicies, policy)
			branches = append(branches, &policyBranch{
				Name:   policyBranchName(fmt.Sprintf("%x", digest.Digest)),
				Policy: policy.policy.Policy,
			})
			break
		}
	}
	if len(candidatePolicies) == 0 {
		return errors.New("no valid candidate policies")
	}

	next, remaining := h.remaining.PopNextComponent()
	switch {
	case len(next) > 0 && next[0] == '$':
		// Don't permit numeric selectors for authorized policies.
		return fmt.Errorf("invalid path component \"%s\" for authorized policy selector", next)
	case len(next) == 0 || next[0] == '*':
		// There are no more components or the next component is a wildcard match - build a
		// list of candidate paths for this subtree
		resources := h.resources
		if !h.hasResources {
			resources = nil
		}
		selector := newPolicyBranchSelector(h.sessionAlg, resources, h.controller, h.subPolicyRunner, h.tpm, h.usage, h.ignoreAuthorizations, h.ignoreNV)
		if err := selector.selectPath(branches, func(path policyBranchPath) error {
			switch next {
			case "":
				// We have a path for this whole subtree
				h.remaining = path
			case "**":
				// Prepend the path for this whole subtree to the remaining components
				h.remaining = path.Concat(remaining)
			case "*":
				// Prepend the first component of the path for this subtree to the remaining components
				component, _ := path.PopNextComponent()
				h.remaining = component.Concat(remaining)
			default:
				panic("not reached")
			}

			// rerun
			h.controller.pushTasks(func() error {
				if err := h.handleAuthorizedPolicy(keySign, policyRef, policies, complete); err != nil {
					return &PolicyAuthorizationError{AuthName: keySign.Name(), PolicyRef: policyRef, err: err}
				}
				return nil
			})
			return nil
		}); err != nil {
			return fmt.Errorf("cannot filter inappropriate policies: %w", err)
		}
		return nil
	}

	// We have a policy selector
	h.remaining = remaining
	selected, err := h.selectBranch(branches, next)
	if err != nil {
		return err
	}

	h.controller.setCurrentPath(h.controller.currentPath().Concat(next))

	policy := candidatePolicies[selected]

	// Find the approved digest
	var approvedPolicy tpm2.Digest
	for _, digest := range policy.policy.PolicyDigests {
		if digest.HashAlg != h.sessionAlg {
			continue
		}
		approvedPolicy = digest.Digest
		break
	}
	if approvedPolicy == nil {
		// XXX: this shouldn't happen
		return ErrMissingDigest
	}

	// Find the signed authorization
	var policyAuth *PolicyAuthorization
	for _, auth := range policy.policy.PolicyAuthorizations {
		if !bytes.Equal(auth.AuthKey.Name(), keySign.Name()) {
			continue
		}
		if !bytes.Equal(auth.PolicyRef, policyRef) {
			continue
		}
		policyAuth = &auth
		break
	}
	if policyAuth == nil || policyAuth.Signature == nil {
		// this should only happen if the caller supplied policies without
		// a valid authorization
		return errors.New("missing policy authorization")
	}

	// Verify the signature
	authKey, err := h.tpm.LoadExternal(nil, keySign, tpm2.HandleOwner)
	if err != nil {
		return err
	}
	defer func() {
		h.tpm.FlushContext(authKey)
	}()

	tbs := ComputePolicyAuthorizationTBSDigest(keySign.Name().Algorithm().GetHash(), approvedPolicy, policyRef)
	ticket, err := h.tpm.VerifySignature(authKey, tbs, policyAuth.Signature)
	if err != nil {
		return err
	}

	// Run it
	h.controller.pushTasks(func() error {
		if err := complete(approvedPolicy, ticket); err != nil {
			return fmt.Errorf("cannot complete: %w", err)
		}
		return nil
	})
	h.controller.pushElements(policy.policy.Policy)

	return nil
}

// Execute runs this policy using the supplied TPM context and on the supplied policy session.
//
// The caller may supply additional parameters via the PolicyExecuteParams struct, which is an
// optional argument.
//
// Resources required by a policy are obtained from the supplied PolicyResourceLoader, which is
// optional but must be supplied for any policy that executes TPM2_PolicyNV, TPM2_PolicySecret,
// TPM2_PolicySigned or TPM2_PolicyAuthorize assertions.
//
// The caller may explicitly select branches and authorized policies to execute via the Path
// argument of [PolicyExecuteParams]. Alternatively, if a path os not specified explicitly,
// or a component contains a wildcard match, an appropriate execution path is selected
// automatically where possible. This works by selecting the first path from all of the
// candidate paths, with a preference for paths that don't include TPM2_PolicySecret,
// TPM2_PolicySigned, TPM2_PolicyAuthValue, and TPM2_PolicyPassword assertions. It also has a
// preference for paths that don't include TPM2_PolicyNV assertions that require authorization
// to use or read. A path is omitted from the set of candidate paths if any of the following
// conditions are true:
//   - It contains a command code, command parameter hash, or name hash that doesn't match
//     the supplied [PolicySessionUsage].
//   - It contains a TPM2_PolicyAuthValue or TPM2_PolicyPassword assertion and this isn't permitted
//     bt the supplied [PolicySessionUsage].
//   - It uses TPM2_PolicyNvWritten with a value that doesn't match the public area of the NV index
//     provided via the supplied [PolicySessionUsage].
//   - It uses TPM2_PolicySigned, TPM2_PolicySecret or TPM2_PolicyAuthorize and the specific
//     authorization is included in the IgnoreAuthorizations field of [PolicyExecuteParams].
//   - It uses TPM2_PolicyNV and the NV index is included in the IgnoreNV field of
//     [PolicyExecuteParams]
//   - It uses TPM2_PolicyNV with conditions that will fail against the current NV index contents,
//     if the index has an authorization policy that permits the use of TPM2_NV_Read without any
//     other conditions, else the condition isn't checked.
//   - It uses TPM2_PolicyPCR with values that don't match the current PCR values.
//   - It uses TPM2_PolicyCounterTimer with conditions that will fail.
//
// On success, the supplied policy session may be used for authorization in a context that requires
// that this policy is satisfied. It will also return a list of tickets generated by any assertions -
// this may include supplied tickets if they are still valid or weren't used. It will indicate whether
// the authorization value must be supplied for the resource being authorized.
func (p *Policy) Execute(tpm TPMConnection, session tpm2.SessionContext, resources PolicyResourceLoader, params *PolicyExecuteParams) (tickets []*PolicyTicket, requireAuthValue bool, err error) {
	if tpm == nil {
		return nil, false, errors.New("no TPM")
	}
	if session == nil {
		return nil, false, errors.New("no session")
	}
	hasResources := resources != nil
	if resources == nil {
		resources = new(nullPolicyResourceLoader)
	}
	if params == nil {
		params = new(PolicyExecuteParams)
	}

	executor := new(policyExecutor)

	var details PolicyBranchDetails
	ticketMap := makeExecutePolicyTickets()

	runner := newPolicyRunner(
		newProxyPolicySession(newTpmPolicySession(tpm, session), &details),
		ticketMap,
		resources,
		func(runner *policyRunner) policyRunnerHelper {
			return newExecutePolicyHelper(runner, tpm, params, executor, hasResources)
		},
	)
	for _, ticket := range params.Tickets {
		ticketMap[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
	}

	if err := executor.run(runner, p.policy.Policy); err != nil {
		return nil, false, err
	}

	for _, ticket := range ticketMap {
		tickets = append(tickets, ticket)
	}

	return tickets, details.AuthValueNeeded, nil
}

type nullTickets struct{}

func (*nullTickets) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	return nil
}

func (*nullTickets) addTicket(ticket *PolicyTicket)    {}
func (*nullTickets) removeTicket(ticket *PolicyTicket) {}

func computeBranchDigests(controller policyRunnerController, branches policyBranches, done func(tpm2.DigestList) error) error {
	currentDigest, err := controller.session().PolicyGetDigest()
	if err != nil {
		return err
	}

	currentPath := controller.currentPath()

	var digests tpm2.DigestList

	var tasks []taskFn
	for i, branch := range branches {
		i := i
		branch := branch
		task := func() error {
			digest := taggedHash{HashAlg: controller.session().HashAlg(), Digest: currentDigest}

			restoreSession := controller.setSession(newComputePolicySession(&digest))

			name := policyBranchPath(branch.Name)
			if len(name) == 0 {
				name = policyBranchPath(fmt.Sprintf("$[%d]", i))
			}
			restorePath := controller.setCurrentPath(currentPath.Concat(name))

			controller.pushTasks(func() error {
				restorePath()
				restoreSession()
				digests = append(digests, digest.Digest)
				if len(digests) != len(branches) {
					return nil
				}

				return done(digests)
			})
			controller.pushElements(branch.Policy)

			return nil
		}
		tasks = append(tasks, task)
	}
	controller.pushTasks(tasks...)

	return nil
}

type computePolicyHelper struct {
	controller policyRunnerController
	hasCpHash  *bool
}

func newComputePolicyHelper(runner *policyRunner, hasCpHash *bool) *computePolicyHelper {
	return &computePolicyHelper{
		controller: runner,
		hasCpHash:  hasCpHash,
	}
}

func (h *computePolicyHelper) loadExternal(public *tpm2.Public) (ResourceContext, error) {
	// the handle is not relevant here
	resource := tpm2.NewLimitedResourceContext(0x80000000, public.Name())
	return newResourceContextFlushable(resource, nil), nil
}

func (h *computePolicyHelper) cpHash(cpHash *policyCpHashElement) error {
	if h.hasCpHash != nil {
		*h.hasCpHash = true
	}
	digest, err := computeCpHash(h.controller.session().HashAlg(), cpHash.CommandCode, cpHash.Handles, cpHash.CpBytes)
	if err != nil {
		return fmt.Errorf("cannot compute cpHashA: %w", err)
	}
	cpHash.Digest = digest
	return nil
}

func (h *computePolicyHelper) nameHash(nameHash *policyNameHashElement) error {
	if h.hasCpHash != nil {
		*h.hasCpHash = true
	}
	digest, err := computeNameHash(h.controller.session().HashAlg(), nameHash.Handles)
	if err != nil {
		return fmt.Errorf("cannot compute nameHash: %w", err)
	}
	nameHash.Digest = digest
	return nil
}

func (h *computePolicyHelper) authorize(auth tpm2.ResourceContext, policy *Policy, usage *PolicySessionUsage, prefer tpm2.SessionType, complete func(error, tpm2.SessionContext) error) error {
	h.controller.pushTasks(func() error {
		return complete(nil, nil)
	})
	return nil
}

func (h *computePolicyHelper) handleBranches(branches policyBranches, complete func(tpm2.DigestList, int) error) error {
	if err := computeBranchDigests(h.controller, branches, func(digests tpm2.DigestList) error {
		for i, branch := range branches {
			found := false
			computedDigest := digests[i]
			for j, digest := range branch.PolicyDigests {
				if digest.HashAlg != h.controller.session().HashAlg() {
					continue
				}

				branch.PolicyDigests[j] = taggedHash{HashAlg: h.controller.session().HashAlg(), Digest: computedDigest}
				found = true
				break
			}
			if !found {
				branch.PolicyDigests = append(branch.PolicyDigests, taggedHash{HashAlg: h.controller.session().HashAlg(), Digest: computedDigest})
			}
		}

		h.controller.pushTasks(func() error {
			if err := complete(digests, 0); err != nil {
				return fmt.Errorf("cannot complete: %w", err)
			}
			return nil
		})
		return nil
	}); err != nil {
		return fmt.Errorf("cannot compute branch digests: %w", err)
	}

	return nil
}

func (h *computePolicyHelper) handleAuthorizedPolicy(keySign *tpm2.Public, policyRef tpm2.Nonce, policies []*Policy, complete func(tpm2.Digest, *tpm2.TkVerified) error) error {
	h.controller.pushTasks(func() error {
		if err := complete(nil, nil); err != nil {
			return fmt.Errorf("cannot complete: %w", err)
		}
		return nil
	})
	return nil
}

func (p *Policy) computeForDigest(digest *taggedHash) error {
	var policy *policy
	if err := mu.CopyValue(&policy, p.policy); err != nil {
		return fmt.Errorf("cannot make temporary copy of policy: %w", err)
	}

	var hasCpHash bool

	runner := newPolicyRunner(
		newComputePolicySession(digest),
		new(nullTickets),
		new(mockPolicyResourceLoader),
		func(runner *policyRunner) policyRunnerHelper { return newComputePolicyHelper(runner, &hasCpHash) },
	)

	if err := runner.run(policy.Policy); err != nil {
		return err
	}

	addedDigest := false
	for i, d := range policy.PolicyDigests {
		if d.HashAlg == digest.HashAlg {
			policy.PolicyDigests[i] = *digest
			addedDigest = true
			break
		}
	}
	if !addedDigest {
		policy.PolicyDigests = append(policy.PolicyDigests, *digest)
	}

	if hasCpHash && len(policy.PolicyDigests) > 1 {
		return errors.New("policies that use TPM2_PolicyCpHash and TPM2_PolicyNameHash can't be computed for more than one digest algorithm")
	}

	p.policy = *policy
	return nil
}

// Compute computes the digest for this policy for the specified algorithm. This also
// updates stored digests within the policy, so the policy should be persisted after
// calling this. On success, it returns the computed digest.
//
// Policies that contain TPM2_PolicyCpHash or TPM2_PolicyNameHash assertions can only
// be computed for a single digest algorithm. An error will be returned if the policy has
// already been computed for another algorithm.
func (p *Policy) Compute(alg tpm2.HashAlgorithmId) (tpm2.Digest, error) {
	if !alg.IsValid() {
		return nil, errors.New("invalid algorithm")
	}

	for _, digest := range p.policy.PolicyDigests {
		if digest.HashAlg == alg {
			return digest.Digest, nil
		}
	}

	digest := taggedHash{HashAlg: alg, Digest: make(tpm2.Digest, alg.Size())}
	if err := p.computeForDigest(&digest); err != nil {
		return nil, err
	}

	return digest.Digest, nil
}

// Authorize signs this policy with the supplied signer so that it can be used as an
// authorized policy for a TPM2_PolicyAuthorize assertion with the supplied authKey and
// policyRef. Calling this updates the policy, so it should be persisted afterwards.
//
// TPM2_PolicyAuthorize expects the digest algorithm of the signature to match the name
// algorithm of the public key, so the name algorithm of authKey must match the algorithm
// supplied through the opts argument. This function also uses the name algorithm of
// authKey to select the policy digest to sign, so the name algorithm of authKey should
// match the name algorithm of the resource that this policy is associated with.
//
// This will compute the policy for the selected algorithm if it hasn't been computed
// already.
func (p *Policy) Authorize(rand io.Reader, authKey *tpm2.Public, policyRef tpm2.Nonce, signer crypto.Signer, opts crypto.SignerOpts) error {
	authName := authKey.Name()
	hashAlg := authName.Algorithm()
	if opts.HashFunc() != hashAlg.GetHash() {
		return errors.New("mismatched authKey name and opts")
	}

	approvedPolicy, err := p.Compute(hashAlg)
	if err != nil {
		return fmt.Errorf("cannot compute digest: %w", err)
	}

	policyAuth, err := SignPolicyAuthorization(rand, approvedPolicy, authKey, policyRef, signer, opts)
	if err != nil {
		return fmt.Errorf("cannot sign authorization: %w", err)
	}

	addedAuth := false
	for i, auth := range p.policy.PolicyAuthorizations {
		if bytes.Equal(auth.AuthKey.Name(), authName) && bytes.Equal(auth.PolicyRef, policyRef) {
			p.policy.PolicyAuthorizations[i] = *policyAuth
			addedAuth = true
			break
		}
	}
	if !addedAuth {
		p.policy.PolicyAuthorizations = append(p.policy.PolicyAuthorizations, *policyAuth)
	}

	return nil
}

type validatePolicyHelper struct {
	controller policyRunnerController
}

func newValidatePolicyHelper(runner *policyRunner) *validatePolicyHelper {
	return &validatePolicyHelper{controller: runner}
}

func (h *validatePolicyHelper) loadExternal(public *tpm2.Public) (ResourceContext, error) {
	// the handle is not relevant here
	resource := tpm2.NewLimitedResourceContext(0x80000000, public.Name())
	return newResourceContextFlushable(resource, nil), nil
}

func (h *validatePolicyHelper) cpHash(cpHash *policyCpHashElement) error {
	digest, err := computeCpHash(h.controller.session().HashAlg(), cpHash.CommandCode, cpHash.Handles, cpHash.CpBytes)
	if err != nil {
		return fmt.Errorf("cannot compute cpHashA: %w", err)
	}
	if !bytes.Equal(digest, cpHash.Digest) {
		return fmt.Errorf("stored and computed cpHashA mismatch (computed: %x, stored: %x)", digest, cpHash.Digest)
	}
	return nil
}

func (h *validatePolicyHelper) nameHash(nameHash *policyNameHashElement) error {
	digest, err := computeNameHash(h.controller.session().HashAlg(), nameHash.Handles)
	if err != nil {
		return fmt.Errorf("cannot compute nameHash: %w", err)
	}
	if !bytes.Equal(digest, nameHash.Digest) {
		return fmt.Errorf("stored and computed nameHash mismatch (computed: %x, stored: %x)", digest, nameHash.Digest)
	}
	return nil
}

func (h *validatePolicyHelper) authorize(auth tpm2.ResourceContext, policy *Policy, usage *PolicySessionUsage, prefer tpm2.SessionType, complete func(error, tpm2.SessionContext) error) error {
	h.controller.pushTasks(func() error {
		return complete(nil, nil)
	})
	return nil
}

func (h *validatePolicyHelper) handleBranches(branches policyBranches, complete func(tpm2.DigestList, int) error) error {
	if err := computeBranchDigests(h.controller, branches, func(digests tpm2.DigestList) error {
		for i, branch := range branches {
			found := false
			computedDigest := digests[i]
			for _, digest := range branch.PolicyDigests {
				if digest.HashAlg != h.controller.session().HashAlg() {
					continue
				}
				if !bytes.Equal(digest.Digest, computedDigest) {
					return fmt.Errorf("stored and computed branch digest mismatch (computed: %x, stored: %x)", computedDigest, digest.Digest)
				}
				found = true
				break
			}
			if !found {
				return ErrMissingDigest
			}
		}

		h.controller.pushTasks(func() error {
			if err := complete(digests, 0); err != nil {
				return fmt.Errorf("cannot complete: %w", err)
			}
			return nil
		})
		return nil
	}); err != nil {
		return fmt.Errorf("cannot compute branch digests: %w", err)
	}

	return nil
}

func (h *validatePolicyHelper) handleAuthorizedPolicy(keySign *tpm2.Public, policyRef tpm2.Nonce, policies []*Policy, complete func(tpm2.Digest, *tpm2.TkVerified) error) error {
	h.controller.pushTasks(func() error {
		if err := complete(nil, nil); err != nil {
			return fmt.Errorf("cannot complete: %w", err)
		}
		return nil
	})
	return nil
}

// Validate performs some checking of every element in the policy, and
// verifies that every branch is consistent with their stored digests. On
// success, it returns the digest correpsonding to this policy for the
// specified digest algorithm.
func (p *Policy) Validate(alg tpm2.HashAlgorithmId) (tpm2.Digest, error) {
	var expectedDigest tpm2.Digest
	for _, digest := range p.policy.PolicyDigests {
		if digest.HashAlg != alg {
			continue
		}

		expectedDigest = digest.Digest
		break
	}
	if expectedDigest == nil {
		return nil, ErrMissingDigest
	}

	digest := &taggedHash{HashAlg: alg, Digest: make(tpm2.Digest, alg.Size())}

	runner := newPolicyRunner(
		newComputePolicySession(digest),
		new(nullTickets),
		new(mockPolicyResourceLoader),
		func(runner *policyRunner) policyRunnerHelper { return newValidatePolicyHelper(runner) },
	)
	if err := runner.run(p.policy.Policy); err != nil {
		return nil, err
	}

	if !bytes.Equal(digest.Digest, expectedDigest) {
		return nil, fmt.Errorf("stored and computed policy digest mismatch (computed: %x, stored: %x)", digest.Digest, expectedDigest)
	}

	for _, auth := range p.policy.PolicyAuthorizations {
		if auth.AuthKey.Name().Algorithm() != alg {
			continue
		}

		ok, err := auth.Verify(digest.Digest)
		if err != nil {
			return nil, &PolicyAuthorizationError{AuthName: auth.AuthKey.Name(), PolicyRef: auth.PolicyRef, err: fmt.Errorf("cannot verify signature: %w", err)}
		}
		if !ok {
			return nil, &PolicyAuthorizationError{AuthName: auth.AuthKey.Name(), PolicyRef: auth.PolicyRef, err: errors.New("invalid signature")}
		}
	}

	return expectedDigest, nil
}

// Branches returns the path of every branch in this policy. A TPM2_PolicyAuthorize assertion
// is represented by a "â€¦" component in a path.
func (p *Policy) Branches() ([]string, error) {
	var result []string

	var currentPath policyBranchPath

	walker := newTreeWalker(
		newNullPolicySession(tpm2.HashAlgorithmSHA256),
		new(mockPolicyResourceLoader),
		func() (treeWalkerBeginBranchFn, treeWalkerEndBranchFn, error) {
			path := currentPath

			return func(name policyBranchPath) error {
				currentPath = path.Concat(name)
				return nil
			}, nil, nil
		},
		func() error {
			result = append(result, string(currentPath))
			return nil
		},
	)

	if err := walker.run(p.policy.Policy); err != nil {
		return nil, err
	}

	return result, nil
}

// PolicyNVDetails contains the properties of a TPM2_PolicyNV assertion.
type PolicyNVDetails struct {
	Auth      tpm2.Handle
	Index     tpm2.Handle
	Name      tpm2.Name
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

// PolicyAuthorizationDetails contains the properties of a TPM2_PolicySecret,
// TPM2_PolicySigned or TPM2_PolicyAuthorize assertion.
type PolicyAuthorizationDetails struct {
	AuthName  tpm2.Name
	PolicyRef tpm2.Nonce
}

// PolicyCounterTimerDetails contains the properties of a TPM2_PolicyCounterTimer
// assertion.
type PolicyCounterTimerDetails struct {
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

// PolicyPCRDetails contains the properties of a TPM2_PolicyPCR assertion.
type PolicyPCRDetails struct {
	PCRDigest tpm2.Digest
	PCRs      tpm2.PCRSelectionList
}

// PolicyBranchDetails contains the properties of a single policy branch.
type PolicyBranchDetails struct {
	NV                []PolicyNVDetails            // TPM2_PolicyNV assertions
	Secret            []PolicyAuthorizationDetails // TPM2_PolicySecret assertions
	Signed            []PolicyAuthorizationDetails // TPM2_PolicySigned assertions
	Authorize         []PolicyAuthorizationDetails // TPM2_PolicyAuthorize assertions
	AuthValueNeeded   bool                         // The branch contains a TPM2_PolicyAuthValue or TPM2_PolicyPassword assertion
	policyCommandCode tpm2.CommandCodeList
	CounterTimer      []PolicyCounterTimerDetails // TPM2_PolicyCounterTimer assertions
	policyCpHash      tpm2.DigestList
	policyNameHash    tpm2.DigestList
	PCR               []PolicyPCRDetails // TPM2_PolicyPCR assertions
	policyNvWritten   []bool
}

// IsValid indicates whether the corresponding policy branch is valid.
func (r *PolicyBranchDetails) IsValid() bool {
	if len(r.policyCommandCode) > 1 {
		for _, code := range r.policyCommandCode[1:] {
			if code != r.policyCommandCode[0] {
				return false
			}
		}
	}

	cpHashNum := 0
	if len(r.policyCpHash) > 0 {
		if len(r.policyCpHash) > 1 {
			for _, cpHash := range r.policyCpHash[1:] {
				if !bytes.Equal(cpHash, r.policyCpHash[0]) {
					return false
				}
			}
		}
		cpHashNum += 1
	}
	if len(r.policyNameHash) > 0 {
		if len(r.policyNameHash) > 1 {
			return false
		}
		cpHashNum += 1
	}
	if cpHashNum > 1 {
		return false
	}
	if len(r.policyNvWritten) > 1 {
		for _, nvWritten := range r.policyNvWritten[1:] {
			if nvWritten != r.policyNvWritten[0] {
				return false
			}
		}
	}

	return true
}

// The command code associated with a branch if set, either set by the TPM2_PolicyCommandCode
// or TPM2_PolicyDuplicationSelect assertion.
func (r *PolicyBranchDetails) CommandCode() (code tpm2.CommandCode, set bool) {
	if len(r.policyCommandCode) == 0 {
		return 0, false
	}
	return r.policyCommandCode[0], true
}

// The cpHash associated with a branch if set, either set by the TPM2_PolicyCpHash,
// TPM2_PolicySecret, or TPM2_PolicySigned assertions.
func (r *PolicyBranchDetails) CpHash() (cpHashA tpm2.Digest, set bool) {
	if len(r.policyCpHash) == 0 {
		return nil, false
	}
	return r.policyCpHash[0], true
}

// The nameHash associated with a branch if set, either set by the TPM2_PolicyNameHash
// or TPM2_PolicyDuplicationSelect assertion.
func (r *PolicyBranchDetails) NameHash() (nameHash tpm2.Digest, set bool) {
	if len(r.policyNameHash) == 0 {
		return nil, false
	}
	return r.policyNameHash[0], true
}

// The nvWrittenSet value associated with a branch if set.
func (r *PolicyBranchDetails) NvWritten() (nvWrittenSet bool, set bool) {
	if len(r.policyNvWritten) == 0 {
		return false, false
	}
	return r.policyNvWritten[0], true
}

// Details returns details of all branches with the supplied path prefix, for
// the specified algorithm.
func (p *Policy) Details(alg tpm2.HashAlgorithmId, path string) (map[string]PolicyBranchDetails, error) {
	result := make(map[string]PolicyBranchDetails)

	var (
		remainingPath  = policyBranchPath(path)
		currentDetails PolicyBranchDetails
		currentPath    policyBranchPath
		consumeGreedy  bool
	)

	var walker *treeWalker
	walker = newTreeWalker(
		newProxyPolicySession(newNullPolicySession(alg), &currentDetails),
		new(mockPolicyResourceLoader),
		func() (treeWalkerBeginBranchFn, treeWalkerEndBranchFn, error) {
			details := currentDetails
			path := currentPath

			var next policyBranchPath
			thisNodeConsumingGreedy := false
			if consumeGreedy {
				next = "*"
			} else {
				next, remainingPath = remainingPath.PopNextComponent()
				if next == "**" {
					consumeGreedy = true
					thisNodeConsumingGreedy = true
				}
			}

			explicitlyHandledNode := false

			beginBranchFn := func(name policyBranchPath) error {
				if explicitlyHandledNode {
					return errTreeWalkerSkipBranch
				}
				switch {
				case len(next) == 0 || next[0] == '*':
					// ok
				case next == name:
					// ok
					explicitlyHandledNode = true
				default:
					return errTreeWalkerSkipBranch
				}

				currentPath = path.Concat(name)
				currentDetails = details
				walker.runner.setSession(newProxyPolicySession(
					newNullPolicySession(alg),
					&currentDetails,
				))
				return nil
			}

			endBranchFn := func() error {
				if thisNodeConsumingGreedy {
					consumeGreedy = false
				}
				return nil
			}

			return beginBranchFn, endBranchFn, nil
		},
		func() error {
			result[string(currentPath)] = currentDetails
			return nil
		},
	)

	if err := walker.run(p.policy.Policy); err != nil {
		return nil, err
	}

	return result, nil
}
