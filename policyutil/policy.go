// Copyright 2023 Canonical Ltd.
// Licensed under the LGPLv3 with static-linking exception.
// See LICENCE file for details.

package policyutil

import (
	"bytes"
	"crypto"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"reflect"
	"strings"
	"unicode/utf8"

	"github.com/canonical/go-tpm2"
	"github.com/canonical/go-tpm2/mu"
)

var (
	// ErrMissingDigest is returned from [Policy.Execute] when a TPM2_PolicyCpHash or
	// TPM2_PolicyNameHash assertion is missing a digest for the selected session algorithm.
	ErrMissingDigest = errors.New("missing digest for session algorithm")
)

type (
	taskFn   func() error
	paramKey [sha256.Size]byte
)

func policyParamKey(authName tpm2.Name, policyRef tpm2.Nonce) paramKey {
	h := crypto.SHA256.New()
	h.Write(authName)
	h.Write(policyRef)

	var key paramKey
	copy(key[:], h.Sum(nil))
	return key
}

// PolicyTicket corresponds to a ticket generated from a TPM2_PolicySigned or TPM2_PolicySecret
// assertion and is returned by [Policy.Execute]. Generated tickets can be supplied to
// [Policy.Execute] in the future in order to satisfy these assertions as long as they haven't
// expired.
type PolicyTicket struct {
	AuthName  tpm2.Name    // The name of the auth object associated with the corresponding assertion
	PolicyRef tpm2.Nonce   // The policy ref of the corresponding assertion
	CpHash    tpm2.Digest  // The cpHash supplied to the assertion that generated this ticket
	Timeout   tpm2.Timeout // The timeout returned by the assertion that generated this ticket

	// Ticket is the actual ticket returned by the TPM for the assertion that generated this ticket.
	// The Tag field indicates whether this was generated by TPM2_PolicySigned or TPM2_PolicySecret.
	Ticket *tpm2.TkAuth
}

// AuthorizationError is returned from [Policy.Execute] if the policy uses TPM2_PolicySecret
// and the associated object could not be authorized, or if the policy uses TPM2_PolicySigned
// and no or an invalid signed authorization was supplied.
type AuthorizationError struct {
	AuthName  tpm2.Name
	PolicyRef tpm2.Nonce
	err       error
}

func (e *AuthorizationError) Error() string {
	return fmt.Sprintf("authorization failed for assertion with authName=%#x, policyRef=%#x: %v", e.AuthName, e.PolicyRef, e.err)
}

func (e *AuthorizationError) Unwrap() error {
	return e.err
}

// ResourceLoadError is returned from [Policy.Execute] if the policy required a resource that
// could not be loaded.
type ResourceLoadError struct {
	Name tpm2.Name
	err  error
}

func (e *ResourceLoadError) Error() string {
	return fmt.Sprintf("cannot load resource with name %#x: %v", e.Name, e.err)
}

func (e *ResourceLoadError) Unwrap() error {
	return e.err
}

type policyBranchName string

func (n policyBranchName) isValid() bool {
	if !utf8.ValidString(string(n)) {
		return false
	}
	if len(n) > 0 && n[0] == '$' {
		return false
	}
	return true
}

func (n policyBranchName) Marshal(w io.Writer) error {
	if !n.isValid() {
		return errors.New("invalid name")
	}
	_, err := mu.MarshalToWriter(w, []byte(n))
	return err
}

func (n *policyBranchName) Unmarshal(r io.Reader) error {
	var b []byte
	if _, err := mu.UnmarshalFromReader(r, &b); err != nil {
		return err
	}
	name := policyBranchName(b)
	if !name.isValid() {
		return errors.New("invalid name")
	}
	*n = name
	return nil
}

type policyBranchPath string

func (p policyBranchPath) PopNextComponent() (next policyBranchPath, remaining policyBranchPath) {
	remaining = p
	for len(remaining) > 0 {
		s := strings.SplitN(string(remaining), "/", 2)
		remaining = ""
		if len(s) == 2 {
			remaining = policyBranchPath(s[1])
		}
		component := policyBranchPath(s[0])
		if len(component) > 0 {
			return component, remaining
		}
	}

	return "", ""
}

func (p policyBranchPath) Concat(path policyBranchPath) policyBranchPath {
	var pathElements []string
	if p != "" {
		pathElements = append(pathElements, string(p))
	}
	if path != "" {
		pathElements = append(pathElements, string(path))
	}
	return policyBranchPath(strings.Join(pathElements, "/"))
}

// PolicySessionUsage describes how a policy session will be used, and assists with
// automatically selecting branches where a policy has command context-specific branches.
type PolicySessionUsage struct {
	commandCode tpm2.CommandCode
	handles     []Named
	params      []interface{}
	nvHandle    tpm2.Handle
}

// NewPolicySessionUsage creates a new PolicySessionUsage.
func NewPolicySessionUsage(command tpm2.CommandCode, handles []Named, params ...interface{}) *PolicySessionUsage {
	return &PolicySessionUsage{
		commandCode: command,
		handles:     handles,
		params:      params,
	}
}

// WithNVHandle indicates that the policy session is being used to authorize a NV
// index with the specified handle. This will panic if handle is not a NV index.
func (u *PolicySessionUsage) WithNVHandle(handle tpm2.Handle) *PolicySessionUsage {
	if handle.Type() != tpm2.HandleTypeNVIndex {
		panic("invalid handle")
	}
	u.nvHandle = handle
	return u
}

// PolicyBranchSelectParams contains parameters for selecting branches in a policy.
type PolicyBranchSelectParams struct {
	// Usage describes how the executed policy will be used, and assists with
	// automatically selecting branches where a policy has command context-specific
	// branches.
	Usage *PolicySessionUsage

	// Path provides a way to explicitly select branches to execute. A path consists
	// of zero or more components separated by a '/' character, with each component
	// identifying a branch to select when a branch node is encountered. A component
	// can either identify a branch by its name (if it has one), or it can be a numeric
	// identifier of the form "$[n]" which selects the branch at index n.
	//
	// If the path has insufficent components for the branch nodes encountered in a
	// profile, the profile execution will attempt to select an appropriate branch
	// automatically.
	Path string
}

// PolicyExecuteParams contains parameters that are useful for executing a policy.
type PolicyExecuteParams struct {
	SignedAuthorizations []*PolicySignedAuthorization // Authorizations for TPM2_PolicySigned assertions
	Tickets              []*PolicyTicket              // Tickets for TPM2_PolicySecret and TPM2_PolicySigned assertions
	PolicyBranchSelectParams
}

// policyBranchPath uniquely identifies an execution path through the branches in a
// profile, with each branch selector component being separated by a '/' character. A
// branch selector selects a branch at a node, and a branch can either be selected by
// its name (if it has one), or a numeric identifier of the form "$[n]" which selects
// a branch at a node using its index.
//
// The component "$auto" enables autoselection for a node, where a branch will be selected
// automatically. This only works for branches containing TPM2_PolicyPCR assertions
// where the assertion parameters match the current PCR values.
type policyParams interface {
	signedAuthorization(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySignedAuthorization
	ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket
}

type policyResources interface {
	LoadName(name tpm2.Name) (ResourceContext, *Policy, error)
	LoadExternal(public *tpm2.Public) (ResourceContext, error)
	NewSession(nameAlg tpm2.HashAlgorithmId, sessionType tpm2.SessionType) (SessionContext, error)
	Authorize(resource tpm2.ResourceContext) error
}

type policyRunnerHelper interface {
	cpHash(cpHash *policyCpHashElement) (tpm2.Digest, error)
	nameHash(nameHash *policyNameHashElement) (tpm2.Digest, error)
	handleBranches(branches policyBranches) error
}

type policySessionContext interface {
	session() PolicySession
	params() policyParams
	resources() policyResources
	helper() policyRunnerHelper

	ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket
	addTicket(ticket *PolicyTicket)
}

type policyDeferredTask struct {
	taskName string
	fn       taskFn
}

func newDeferredTask(name string, fn taskFn) *policyDeferredTask {
	return &policyDeferredTask{
		taskName: name,
		fn:       fn,
	}
}

func (e *policyDeferredTask) name() string {
	return e.taskName
}

func (e *policyDeferredTask) run(context policySessionContext) error {
	return e.fn()
}

type policyRunnerTaskStack interface {
	pushTasks(tasks []policySessionTask)
	pushTask(name string, fn taskFn)
	pushElements(elements policyElements)
}

type policySessionTask interface {
	name() string
	run(context policySessionContext) error
}

type taggedHash struct {
	HashAlg tpm2.HashAlgorithmId
	Digest  tpm2.Digest
}

func (h taggedHash) Marshal(w io.Writer) error {
	ta := tpm2.MakeTaggedHash(h.HashAlg, h.Digest)
	_, err := mu.MarshalToWriter(w, ta)
	return err
}

func (h *taggedHash) Unmarshal(r io.Reader) error {
	var ta tpm2.TaggedHash
	if _, err := mu.UnmarshalFromReader(r, &ta); err != nil {
		return err
	}

	if ta.HashAlg != tpm2.HashAlgorithmNull && !ta.HashAlg.IsValid() {
		return errors.New("invalid digest algorithm")
	}

	*h = taggedHash{
		HashAlg: ta.HashAlg,
		Digest:  ta.Digest()}
	return nil
}

type taggedHashList []taggedHash

type policyNVElement struct {
	NvIndex   *tpm2.NVPublic
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (*policyNVElement) name() string { return "TPM2_PolicyNV assertion" }

func (e *policyNVElement) run(context policySessionContext) error {
	nvIndex, err := tpm2.NewNVIndexResourceContextFromPub(e.NvIndex)
	if err != nil {
		return fmt.Errorf("cannot create nvIndex context: %w", err)
	}

	var auth ResourceContext = newResourceContextNonFlushable(nvIndex)
	var policy *Policy
	switch {
	default:
	case e.NvIndex.Attrs&tpm2.AttrNVOwnerRead != 0:
		auth, policy, err = context.resources().LoadName(tpm2.MakeHandleName(tpm2.HandleOwner))
	case e.NvIndex.Attrs&tpm2.AttrNVPPRead != 0:
		auth, policy, err = context.resources().LoadName(tpm2.MakeHandleName(tpm2.HandlePlatform))
	}
	if err != nil {
		return fmt.Errorf("cannot create auth context: %w", err)
	}
	if policy != nil {
		return errors.New("unsupported auth method")
	}

	session, err := context.resources().NewSession(auth.Resource().Name().Algorithm(), tpm2.SessionTypeHMAC)
	if err != nil {
		return fmt.Errorf("cannot create session to authorize auth object: %w", err)
	}
	defer func() {
		if session == nil {
			return
		}
		session.Close()
	}()

	if err := context.resources().Authorize(auth.Resource()); err != nil {
		return fmt.Errorf("cannot authorize auth object: %w", err)
	}

	var tpmSession tpm2.SessionContext
	if session != nil {
		tpmSession = session.Session()
	}

	return context.session().PolicyNV(auth.Resource(), nvIndex, e.OperandB, e.Offset, e.Operation, tpmSession)
}

type policySecretElement struct {
	AuthObjectName tpm2.Name
	PolicyRef      tpm2.Nonce
}

func (*policySecretElement) name() string { return "TPM2_PolicySecret assertion" }

func (e *policySecretElement) run(context policySessionContext) error {
	if ticket := context.ticket(e.AuthObjectName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySecret
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySecret
		case err != nil:
			return &AuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: err}
		default:
			// The ticket was accepted
			return nil
		}
	}

	authObject, policy, err := context.resources().LoadName(e.AuthObjectName)
	if err != nil {
		return &ResourceLoadError{Name: e.AuthObjectName, err: err}
	}
	defer func() {
		if authObject.Resource().Handle().Type() != tpm2.HandleTypeTransient {
			return
		}
		authObject.Flush()
	}()
	if policy != nil {
		return &AuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: errors.New("unsupported auth method")}
	}

	session, err := context.resources().NewSession(e.AuthObjectName.Algorithm(), tpm2.SessionTypeHMAC)
	if err != nil {
		return &AuthorizationError{
			AuthName:  e.AuthObjectName,
			PolicyRef: e.PolicyRef,
			err:       fmt.Errorf("cannot create session to authorize auth object: %w", err)}
	}
	defer func() {
		if session == nil {
			return
		}
		session.Close()
	}()

	if err := context.resources().Authorize(authObject.Resource()); err != nil {
		return &AuthorizationError{
			AuthName:  e.AuthObjectName,
			PolicyRef: e.PolicyRef,
			err:       fmt.Errorf("cannot authorize auth object: %w", err)}
	}

	var tpmSession tpm2.SessionContext
	if session != nil {
		tpmSession = session.Session()
	}

	timeout, ticket, err := context.session().PolicySecret(authObject.Resource(), nil, e.PolicyRef, 0, tpmSession)
	if err != nil {
		return &AuthorizationError{AuthName: e.AuthObjectName, PolicyRef: e.PolicyRef, err: err}
	}

	context.addTicket(&PolicyTicket{
		AuthName:  e.AuthObjectName,
		PolicyRef: e.PolicyRef,
		CpHash:    nil,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policySignedElement struct {
	AuthKey   *tpm2.Public
	PolicyRef tpm2.Nonce
}

func (*policySignedElement) name() string { return "TPM2_PolicySigned assertion" }

func (e *policySignedElement) run(context policySessionContext) error {
	authKeyName := e.AuthKey.Name()
	if !authKeyName.IsValid() {
		return errors.New("invalid auth key name")
	}

	if ticket := context.ticket(authKeyName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySigned
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySigned
		case err != nil:
			return &AuthorizationError{AuthName: authKeyName, PolicyRef: e.PolicyRef, err: err}
		default:
			// The ticket was accepted
			return nil
		}
	}

	auth := context.params().signedAuthorization(authKeyName, e.PolicyRef)
	if auth == nil {
		return &AuthorizationError{
			AuthName:  authKeyName,
			PolicyRef: e.PolicyRef,
			err:       errors.New("missing signed authorization"),
		}
	}

	authKey, err := context.resources().LoadExternal(e.AuthKey)
	if err != nil {
		return fmt.Errorf("cannot create authKey context: %w", err)
	}
	defer authKey.Flush()

	includeNonceTPM := false
	if len(auth.NonceTPM) > 0 {
		includeNonceTPM = true
	}

	timeout, ticket, err := context.session().PolicySigned(authKey.Resource(), includeNonceTPM, auth.CpHash, e.PolicyRef, auth.Expiration, auth.Authorization.Signature)
	if err != nil {
		return &AuthorizationError{AuthName: authKeyName, PolicyRef: e.PolicyRef, err: err}
	}

	context.addTicket(&PolicyTicket{
		AuthName:  authKeyName,
		PolicyRef: e.PolicyRef,
		CpHash:    auth.CpHash,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policyAuthValueElement struct{}

func (*policyAuthValueElement) name() string { return "TPM2_PolicyAuthValue assertion" }

func (*policyAuthValueElement) run(context policySessionContext) error {
	return context.session().PolicyAuthValue()
}

type policyCommandCodeElement struct {
	CommandCode tpm2.CommandCode
}

func (*policyCommandCodeElement) name() string { return "TPM2_PolicyCommandCode assertion" }

func (e *policyCommandCodeElement) run(context policySessionContext) error {
	return context.session().PolicyCommandCode(e.CommandCode)
}

type policyCounterTimerElement struct {
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (*policyCounterTimerElement) name() string { return "TPM2_PolicyCounterTimer assertion" }

func (e *policyCounterTimerElement) run(context policySessionContext) error {
	return context.session().PolicyCounterTimer(e.OperandB, e.Offset, e.Operation)
}

type policyCpHashElement struct {
	CommandCode tpm2.CommandCode
	Handles     []tpm2.Name
	CpBytes     []byte

	Digests taggedHashList
}

func (*policyCpHashElement) name() string { return "TPM2_PolicyCpHash assertion" }

func (e *policyCpHashElement) run(context policySessionContext) error {
	cpHashA, err := context.helper().cpHash(e)
	if err != nil {
		return err
	}
	return context.session().PolicyCpHash(cpHashA)
}

type policyNameHashElement struct {
	Handles []tpm2.Name

	Digests taggedHashList
}

func (*policyNameHashElement) name() string { return "TPM2_PolicyNameHash assertion" }

func (e *policyNameHashElement) run(context policySessionContext) error {
	nameHash, err := context.helper().nameHash(e)
	if err != nil {
		return err
	}
	return context.session().PolicyNameHash(nameHash)
}

type policyBranch struct {
	Name          policyBranchName
	PolicyDigests taggedHashList
	Policy        policyElements
}

type policyBranches []*policyBranch

type policyORElement struct {
	Branches policyBranches
}

func (*policyORElement) name() string { return "branch node" }

func (e *policyORElement) run(context policySessionContext) error {
	return context.helper().handleBranches(e.Branches)
}

type pcrValue struct {
	PCR    tpm2.Handle
	Digest taggedHash
}

type pcrValueList []pcrValue

type policyPCRElement struct {
	PCRs pcrValueList
}

func (*policyPCRElement) name() string { return "TPM2_PolicyPCR assertion" }

func (e *policyPCRElement) run(context policySessionContext) error {
	values, err := e.pcrValues()
	if err != nil {
		return err
	}
	pcrs, pcrDigest, err := ComputePCRDigestFromAllValues(context.session().HashAlg(), values)
	if err != nil {
		return fmt.Errorf("cannot compute PCR digest: %w", err)
	}
	return context.session().PolicyPCR(pcrDigest, pcrs)
}

func (e *policyPCRElement) pcrValues() (tpm2.PCRValues, error) {
	values := make(tpm2.PCRValues)
	for i, value := range e.PCRs {
		if value.PCR.Type() != tpm2.HandleTypePCR {
			return nil, fmt.Errorf("invalid PCR handle at index %d", i)
		}
		if err := values.SetValue(value.Digest.HashAlg, int(value.PCR), value.Digest.Digest); err != nil {
			return nil, fmt.Errorf("invalid PCR value at index %d: %w", i, err)
		}
	}
	return values, nil
}

type policyDuplicationSelectElement struct {
	Object        tpm2.Name
	NewParent     tpm2.Name
	IncludeObject bool
}

func (*policyDuplicationSelectElement) name() string { return "TPM2_PolicyDuplicationSelect assertion" }

func (e *policyDuplicationSelectElement) run(context policySessionContext) error {
	return context.session().PolicyDuplicationSelect(e.Object, e.NewParent, e.IncludeObject)
}

type policyPasswordElement struct{}

func (*policyPasswordElement) name() string { return "TPM2_PolicyPassword assertion" }

func (*policyPasswordElement) run(context policySessionContext) error {
	return context.session().PolicyPassword()
}

type policyNvWrittenElement struct {
	WrittenSet bool
}

func (*policyNvWrittenElement) name() string { return "TPM2_PolicyNvWritten assertion" }

func (e *policyNvWrittenElement) run(context policySessionContext) error {
	return context.session().PolicyNvWritten(e.WrittenSet)
}

type policyElementDetails struct {
	NV                *policyNVElement
	Secret            *policySecretElement
	Signed            *policySignedElement
	AuthValue         *policyAuthValueElement
	CommandCode       *policyCommandCodeElement
	CounterTimer      *policyCounterTimerElement
	CpHash            *policyCpHashElement
	NameHash          *policyNameHashElement
	OR                *policyORElement
	PCR               *policyPCRElement
	DuplicationSelect *policyDuplicationSelectElement
	Password          *policyPasswordElement
	NvWritten         *policyNvWrittenElement
}

func (d *policyElementDetails) Select(selector reflect.Value) interface{} {
	switch selector.Interface().(tpm2.CommandCode) {
	case tpm2.CommandPolicyNV:
		return &d.NV
	case tpm2.CommandPolicySecret:
		return &d.Secret
	case tpm2.CommandPolicySigned:
		return &d.Signed
	case tpm2.CommandPolicyAuthValue:
		return &d.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return &d.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return &d.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return &d.CpHash
	case tpm2.CommandPolicyNameHash:
		return &d.NameHash
	case tpm2.CommandPolicyOR:
		return &d.OR
	case tpm2.CommandPolicyPCR:
		return &d.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return &d.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return &d.Password
	case tpm2.CommandPolicyNvWritten:
		return &d.NvWritten
	default:
		return nil
	}
}

type policyElement struct {
	Type    tpm2.CommandCode
	Details *policyElementDetails
}

func (e *policyElement) runner() policySessionTask {
	switch e.Type {
	case tpm2.CommandPolicyNV:
		return e.Details.NV
	case tpm2.CommandPolicySecret:
		return e.Details.Secret
	case tpm2.CommandPolicySigned:
		return e.Details.Signed
	case tpm2.CommandPolicyAuthValue:
		return e.Details.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return e.Details.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return e.Details.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return e.Details.CpHash
	case tpm2.CommandPolicyNameHash:
		return e.Details.NameHash
	case tpm2.CommandPolicyOR:
		return e.Details.OR
	case tpm2.CommandPolicyPCR:
		return e.Details.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return e.Details.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return e.Details.Password
	case tpm2.CommandPolicyNvWritten:
		return e.Details.NvWritten
	default:
		panic("invalid type")
	}
}

func (e *policyElement) name() string {
	return e.runner().name()
}

func (e *policyElement) run(context policySessionContext) error {
	return e.runner().run(context)
}

type policyElements []*policyElement

type policy struct {
	Policy policyElements
}

// Policy corresponds to an authorization policy. It can be serialized with
// [github.com/canonical/go-tpm2/mu].
type Policy struct {
	policy policy
}

// Marshal implements [mu.CustomMarshaller.Marshal].
func (p Policy) Marshal(w io.Writer) error {
	_, err := mu.MarshalToWriter(w, p.policy)
	return err
}

// Unmarshal implements [mu.CustomMarshaller.Unarshal].
func (p *Policy) Unmarshal(r io.Reader) error {
	_, err := mu.UnmarshalFromReader(r, &p.policy)
	return err
}

type policyRunnerContext struct {
	policySession      PolicySession
	policyParams       policyParams
	policyResources    policyResources
	policyRunnerHelper policyRunnerHelper

	tickets map[paramKey]*PolicyTicket
}

func newPolicyRunnerContext(session PolicySession, params policyParams, resources policyResources, helper policyRunnerHelper) *policyRunnerContext {
	return &policyRunnerContext{
		policySession:      session,
		policyParams:       params,
		policyResources:    resources,
		policyRunnerHelper: helper,
		tickets:            make(map[paramKey]*PolicyTicket),
	}
}

type policyRunner struct {
	*policyRunnerContext
	tasks []policySessionTask
}

func (r *policyRunner) session() PolicySession {
	return r.policySession
}

func (r *policyRunner) params() policyParams {
	return r.policyParams
}

func (r *policyRunner) resources() policyResources {
	return r.policyResources
}

func (r *policyRunner) helper() policyRunnerHelper {
	return r.policyRunnerHelper
}

func (r *policyRunner) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	if ticket, exists := r.tickets[policyParamKey(authName, policyRef)]; exists {
		return ticket
	}
	return r.policyParams.ticket(authName, policyRef)
}

func (r *policyRunner) addTicket(ticket *PolicyTicket) {
	if ticket.Ticket == nil || (ticket.Ticket.Hierarchy == tpm2.HandleNull && len(ticket.Ticket.Digest) == 0) {
		// skip null tickets
		return
	}
	r.tickets[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
}

func (r *policyRunner) pushTasks(tasks []policySessionTask) {
	r.tasks = append(tasks, r.tasks...)
}

func (r *policyRunner) pushTask(name string, fn taskFn) {
	r.tasks = append([]policySessionTask{newDeferredTask(name, fn)}, r.tasks...)
}

func (r *policyRunner) pushElements(elements policyElements) {
	var tasks []policySessionTask
	for _, element := range elements {
		tasks = append(tasks, element)
	}
	r.pushTasks(tasks)
}

func (r *policyRunner) more() bool {
	return len(r.tasks) > 0
}

func (r *policyRunner) popTask() policySessionTask {
	task := r.tasks[0]
	r.tasks = r.tasks[1:]
	return task
}

func (r *policyRunner) run(policy policyElements) error {
	r.pushElements(policy)

	for r.more() {
		task := r.popTask()
		if err := task.run(r); err != nil {
			return fmt.Errorf("cannot run %s: %w", task.name(), err)
		}
	}

	return nil
}

// executePolicyParams is an implementation of policyParams that provides real
// parameters.
type executePolicyParams struct {
	authorizations map[paramKey]*PolicySignedAuthorization
	tickets        map[paramKey]*PolicyTicket
}

func newExecutePolicyParams(params *PolicyExecuteParams) *executePolicyParams {
	out := &executePolicyParams{
		authorizations: make(map[paramKey]*PolicySignedAuthorization),
		tickets:        make(map[paramKey]*PolicyTicket),
	}
	for _, auth := range params.SignedAuthorizations {
		if auth.Authorization == nil {
			continue
		}
		out.authorizations[policyParamKey(auth.Authorization.AuthKey.Name(), auth.Authorization.PolicyRef)] = auth
	}
	for _, ticket := range params.Tickets {
		out.tickets[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
	}

	return out
}

func (p *executePolicyParams) signedAuthorization(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySignedAuthorization {
	return p.authorizations[policyParamKey(authName, policyRef)]
}

func (p *executePolicyParams) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	return p.tickets[policyParamKey(authName, policyRef)]
}

type tpmState interface {
	PCRValues(pcrs tpm2.PCRSelectionList) (tpm2.PCRValues, error)
	NVPublic(handle tpm2.Handle) (*tpm2.NVPublic, error)
	ReadClock() (*tpm2.TimeInfo, error)
}

type executePolicyRunnerHelper struct {
	policyBranchSelectMixin
	runner    *policyRunner
	state     tpmState
	remaining policyBranchPath
	usage     *PolicySessionUsage
}

func newExecutePolicyRunnerHelper(runner *policyRunner, state tpmState, params *PolicyExecuteParams) *executePolicyRunnerHelper {
	return &executePolicyRunnerHelper{
		runner:    runner,
		state:     state,
		remaining: policyBranchPath(params.Path),
		usage:     params.Usage,
	}
}

func (h *executePolicyRunnerHelper) selectAndRunNextBranch(branches policyBranches, next policyBranchPath) error {
	var selected int
	switch {
	case next[0] == '$':
		// select branch by index
		if _, err := fmt.Sscanf(string(next), "$[%d]", &selected); err != nil {
			return fmt.Errorf("cannot select branch: badly formatted path component \"%s\": %w", next, err)
		}
		if selected < 0 || selected >= len(branches) {
			return fmt.Errorf("cannot select branch: selected path %d out of range", selected)
		}
	default:
		// select branch by name
		selected = -1
		for i, branch := range branches {
			if len(branch.Name) == 0 {
				continue
			}
			if policyBranchPath(branch.Name) == next {
				selected = i
				break
			}
		}
		if selected == -1 {
			return fmt.Errorf("cannot select branch: no branch with name \"%s\"", next)
		}
	}

	if selected == -1 {
		// the switch branches should have returned a specific error already
		panic("not reached")
	}

	return nil
}

func (h *executePolicyRunnerHelper) cpHash(cpHash *policyCpHashElement) (tpm2.Digest, error) {
	for _, digest := range cpHash.Digests {
		if digest.HashAlg != h.runner.session().HashAlg() {
			continue
		}
		return digest.Digest, nil
	}
	return nil, ErrMissingDigest
}

func (h *executePolicyRunnerHelper) nameHash(nameHash *policyNameHashElement) (tpm2.Digest, error) {
	for _, digest := range nameHash.Digests {
		if digest.HashAlg != h.runner.session().HashAlg() {
			continue
		}
		return digest.Digest, nil
	}
	return nil, ErrMissingDigest
}

func (h *executePolicyRunnerHelper) handleBranches(branches policyBranches) error {
	next, remaining := h.remaining.PopNextComponent()
	if len(next) == 0 {
		autoSelector := newPolicyBranchAutoSelector(h.runner, h.state, h.usage)
		return autoSelector.selectBranch(branches, func(path policyBranchPath) error {
			h.remaining = path
			h.runner.pushElements(policyElements{&policyElement{
				Type: tpm2.CommandPolicyOR,
				Details: &policyElementDetails{
					OR: &policyORElement{Branches: branches}}}})
			return nil
		})
	}

	h.remaining = remaining
	selected, err := h.selectBranch(branches, next)
	if err != nil {
		return err
	}

	var digests tpm2.DigestList
	for _, branch := range branches {
		found := false
		for _, digest := range branch.PolicyDigests {
			if digest.HashAlg != h.runner.session().HashAlg() {
				continue
			}

			digests = append(digests, digest.Digest)
			found = true
			break
		}
		if !found {
			return ErrMissingDigest
		}
	}

	tree, err := newPolicyOrTree(h.runner.session().HashAlg(), digests)
	if err != nil {
		return fmt.Errorf("cannot compute PolicyOR tree: %w", err)
	}

	h.runner.pushTask("complete branch node", func() error {
		pHashLists := tree.selectBranch(selected)

		for _, pHashList := range pHashLists {
			if err := h.runner.session().PolicyOR(pHashList); err != nil {
				return err
			}
		}
		return nil
	})
	h.runner.pushElements(branches[selected].Policy)

	return nil
}

// Execute runs this policy using the supplied TPM context and on the supplied policy session.
//
// The caller may supply additional parameters via the PolicyExecuteParams struct, which is an
// optional argument. This can contain parameters for TPM2_PolicySecret assertions, signed
// authorizations for TPM2_PolicySigned assertions, or tickets to satisfy TPM2_PolicySecret or
// TPM2_PolicySigned assertions. Each of these parameters are associated with a policy assertion
// by a name and policy reference.
//
// Resources required by a policy are obtained from the supplied PolicyExecuteHelper, which is
// optional but must be supplied for any policy that executes TPM2_PolicyNV, TPM2_PolicySecret or
// TPM2_PolicySigned assertions.
//
// The caller may explicitly select branches to execute via the Path argument of
// [PolicyExecuteParams]. Alternatively, if branches are not specified explicitly, an
// appropriate branch is selected automatically where possible. This works by selecting the
// first branch from all of the candidate branches, with a preference for branches that
// don't include TPM2_PolicySecret, TPM2_PolicyAuthValue and TPM2_PolicyPassword assertions.
// Branches are omitted from the set of candidate branches if any of the following conditions are
// true:
//   - It contains a command code, command parameter hash, or name hash that doesn't match
//     the supplied [PolicySessionUsage].
//   - It uses TPM2_PolicyNvWritten with a value that doesn't match the public area of the NV index
//     provided via the supplied [PolicySessionUsage].
//   - It uses TPM2_PolicySigned and there is no [PolicySignedAuthorization] or [PolicyTicket]
//     supplied. Note that if either of these are supplied, it is assumed that they will succeed.
//   - It uses TPM2_PolicyPCR with values that don't match the current PCR values.
//   - It uses TPM2_PolicyCounterTimer with conditions that will fail.
//
// Note that when automatically selecting branches, it is assumed that any TPM2_PolicySecret or
// TPM2_PolicyNV assertions will succeed.
//
// The supplied PolicyExecuteHelper is used to obtain current TPM state when determining which
// branches to execute. This is required for policies that include TPM2_PolicyPCR,
// TPM2_PolicyCounterTimer or TPM2_PolicyNvWritten assertions.
//
// On success, the supplied policy session may be used for authorization in a context that requires
// that this policy is satisfied. It will also return a list of tickets generated by any assertions,
// and indicate whether the authorization value must be supplied for the resource being authorized.
func (p *Policy) Execute(session PolicySession, helper PolicyExecuteHelper, params *PolicyExecuteParams) (tickets []*PolicyTicket, requireAuthValue bool, err error) {
	if session == nil {
		return nil, false, errors.New("no session")
	}
	if helper == nil {
		helper = new(nullPolicyExecuteHelper)
	}
	if params == nil {
		params = new(PolicyExecuteParams)
	}

	var report policySessionReport

	runner := new(policyRunner)
	runner.policyRunnerContext = newPolicyRunnerContext(
		&observingPolicySession{session: session, report: &report},
		newExecutePolicyParams(params),
		helper,
		newExecutePolicyRunnerHelper(runner, helper, params))

	if err := runner.run(p.policy.Policy); err != nil {
		return nil, false, err
	}

	for _, ticket := range runner.tickets {
		tickets = append(tickets, ticket)
	}

	return tickets, report.authValueNeeded, nil
}

// mockPolicyParams is an implementation of policyParams that provides mock parameters
// to compute a policy.
type mockPolicyParams struct{}

func (p *mockPolicyParams) signedAuthorization(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySignedAuthorization {
	return &PolicySignedAuthorization{Authorization: new(PolicyAuthorization)}
}

func (p *mockPolicyParams) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	return nil
}

func computeBranchDigests(runner *policyRunner, branches policyBranches, done func(tpm2.DigestList) error) error {
	currentDigest, err := runner.session().PolicyGetDigest()
	if err != nil {
		return err
	}

	var digests tpm2.DigestList

	var tasks []policySessionTask
	for _, branch := range branches {
		branch := branch
		task := newDeferredTask("compute branch digest", func() error {
			digest := taggedHash{HashAlg: runner.session().HashAlg(), Digest: currentDigest}

			oldContext := runner.policyRunnerContext
			runner.policyRunnerContext = newPolicyRunnerContext(
				newComputePolicySession(&digest),
				oldContext.policyParams,
				oldContext.policyResources,
				oldContext.policyRunnerHelper,
			)

			runner.pushTask("complete compute branch digests", func() error {
				runner.policyRunnerContext = oldContext
				digests = append(digests, digest.Digest)
				if len(digests) != len(branches) {
					return nil
				}

				return done(digests)
			})
			runner.pushElements(branch.Policy)

			return nil
		})
		tasks = append(tasks, task)
	}
	runner.pushTasks(tasks)

	return nil
}

type computePolicyRunnerHelper struct {
	runner *policyRunner
}

func newComputePolicyRunnerHelper(runner *policyRunner) *computePolicyRunnerHelper {
	return &computePolicyRunnerHelper{runner: runner}
}

func (h *computePolicyRunnerHelper) cpHash(cpHash *policyCpHashElement) (tpm2.Digest, error) {
	cpHashA, err := computeCpHash(h.runner.session().HashAlg(), cpHash.CommandCode, cpHash.Handles, cpHash.CpBytes)
	if err != nil {
		return nil, fmt.Errorf("cannot compute cpHashA: %w", err)
	}

	for i, digest := range cpHash.Digests {
		if digest.HashAlg == h.runner.session().HashAlg() {
			cpHash.Digests[i] = taggedHash{HashAlg: h.runner.session().HashAlg(), Digest: cpHashA}
			return cpHashA, nil
		}
	}

	cpHash.Digests = append(cpHash.Digests, taggedHash{HashAlg: h.runner.session().HashAlg(), Digest: cpHashA})
	return cpHashA, nil
}

func (h *computePolicyRunnerHelper) nameHash(nameHash *policyNameHashElement) (tpm2.Digest, error) {
	digest, err := computeNameHash(h.runner.session().HashAlg(), nameHash.Handles)
	if err != nil {
		return nil, fmt.Errorf("cannot compute nameHash: %w", err)
	}

	for i, d := range nameHash.Digests {
		if d.HashAlg == h.runner.session().HashAlg() {
			nameHash.Digests[i] = taggedHash{HashAlg: h.runner.session().HashAlg(), Digest: digest}
			return digest, nil
		}
	}

	nameHash.Digests = append(nameHash.Digests, taggedHash{HashAlg: h.runner.session().HashAlg(), Digest: digest})
	return digest, nil
}

func (h *computePolicyRunnerHelper) handleBranches(branches policyBranches) error {
	if err := computeBranchDigests(h.runner, branches, func(digests tpm2.DigestList) error {
		for i, branch := range branches {
			found := false
			computedDigest := digests[i]
			for j, digest := range branch.PolicyDigests {
				if digest.HashAlg != h.runner.session().HashAlg() {
					continue
				}

				branch.PolicyDigests[j] = taggedHash{HashAlg: h.runner.session().HashAlg(), Digest: computedDigest}
				found = true
				break
			}
			if !found {
				branch.PolicyDigests = append(branch.PolicyDigests, taggedHash{HashAlg: h.runner.session().HashAlg(), Digest: computedDigest})
			}
		}

		tree, err := newPolicyOrTree(h.runner.session().HashAlg(), digests)
		if err != nil {
			return fmt.Errorf("cannot compute PolicyOR tree: %w", err)
		}
		pHashLists := tree.selectBranch(0)

		return h.runner.session().PolicyOR(pHashLists[len(pHashLists)-1])
	}); err != nil {
		return fmt.Errorf("cannot compute branch digests: %w", err)
	}

	return nil
}

func newComputePolicyRunnerContext(runner *policyRunner, digest *taggedHash) *policyRunnerContext {
	return newPolicyRunnerContext(
		newComputePolicySession(digest),
		new(mockPolicyParams),
		new(mockResources),
		newComputePolicyRunnerHelper(runner),
	)
}

func (p *Policy) computeForDigest(digest *taggedHash) error {
	runner := new(policyRunner)
	runner.policyRunnerContext = newComputePolicyRunnerContext(runner, digest)
	return runner.run(p.policy.Policy)
}

// ComputeFor computes the digest for this policy for the specified algorithm. This also
// updates stored digests within the policy, so the policy should be persisted after
// calling this. On success, it returns the computed digest.
func (p *Policy) ComputeFor(alg tpm2.HashAlgorithmId) (tpm2.Digest, error) {
	digest := taggedHash{HashAlg: alg, Digest: make(tpm2.Digest, alg.Size())}

	if err := p.computeForDigest(&digest); err != nil {
		return nil, err
	}

	return digest.Digest, nil
}

type validatePolicyRunnerHelper struct {
	runner *policyRunner
}

func newValidatePolicyRunnerHelper(runner *policyRunner) *validatePolicyRunnerHelper {
	return &validatePolicyRunnerHelper{runner: runner}
}

func (h *validatePolicyRunnerHelper) cpHash(cpHash *policyCpHashElement) (tpm2.Digest, error) {
	cpHashA, err := computeCpHash(h.runner.session().HashAlg(), cpHash.CommandCode, cpHash.Handles, cpHash.CpBytes)
	if err != nil {
		return nil, fmt.Errorf("cannot compute cpHashA: %w", err)
	}

	found := false
	for _, digest := range cpHash.Digests {
		if digest.HashAlg == h.runner.session().HashAlg() {
			if !bytes.Equal(digest.Digest, cpHashA) {
				return nil, fmt.Errorf("stored and computed cpHashA mismatch (computed: %x, stored: %x)", cpHashA, digest.Digest)
			}
			found = true
			break
		}
	}
	if !found {
		return nil, ErrMissingDigest
	}

	return cpHashA, nil
}

func (h *validatePolicyRunnerHelper) nameHash(nameHash *policyNameHashElement) (tpm2.Digest, error) {
	digest, err := computeNameHash(h.runner.session().HashAlg(), nameHash.Handles)
	if err != nil {
		return nil, fmt.Errorf("cannot compute nameHash: %w", err)
	}

	found := false
	for _, d := range nameHash.Digests {
		if d.HashAlg == h.runner.session().HashAlg() {
			if !bytes.Equal(d.Digest, digest) {
				return nil, fmt.Errorf("stored and computed nameHash mismatch (computed: %x, stored: %x)", digest, d.Digest)
			}
			found = true
			break
		}
	}
	if !found {
		return nil, ErrMissingDigest
	}

	return digest, nil
}

func (h *validatePolicyRunnerHelper) handleBranches(branches policyBranches) error {
	if err := computeBranchDigests(h.runner, branches, func(digests tpm2.DigestList) error {
		for i, branch := range branches {
			found := false
			computedDigest := digests[i]
			for _, digest := range branch.PolicyDigests {
				if digest.HashAlg != h.runner.session().HashAlg() {
					continue
				}
				if !bytes.Equal(digest.Digest, computedDigest) {
					return fmt.Errorf("stored and computed branch digest mismatch (computed: %x, stored: %x)", computedDigest, digest.Digest)
				}
				found = true
				break
			}
			if !found {
				return ErrMissingDigest
			}
		}
		tree, err := newPolicyOrTree(h.runner.session().HashAlg(), digests)
		if err != nil {
			return fmt.Errorf("cannot compute PolicyOR tree: %w", err)
		}
		pHashLists := tree.selectBranch(0)

		for _, pHashList := range pHashLists {
			if err := h.runner.session().PolicyOR(pHashList); err != nil {
				return err
			}
		}

		return nil
	}); err != nil {
		return fmt.Errorf("cannot compute branch digests: %w", err)
	}

	return nil
}

func newValidatePolicyRunnerContext(runner *policyRunner, digest *taggedHash) *policyRunnerContext {
	return newPolicyRunnerContext(
		newComputePolicySession(digest),
		new(mockPolicyParams),
		new(mockResources),
		newValidatePolicyRunnerHelper(runner),
	)
}

// Validate performs some checking of every element in the policy, and
// verifies that every branch is consistent with their stored digests. On
// success, it returns the digest correpsonding to this policy for the
// specified digest algorithm.
func (p *Policy) Validate(alg tpm2.HashAlgorithmId) (tpm2.Digest, error) {
	digest := &taggedHash{HashAlg: alg, Digest: make(tpm2.Digest, alg.Size())}

	runner := new(policyRunner)
	runner.policyRunnerContext = newValidatePolicyRunnerContext(runner, digest)
	if err := runner.run(p.policy.Policy); err != nil {
		return nil, err
	}

	//for _, d := range p.policy.PolicyDigests {
	//	if d.HashAlg != alg {
	//		continue
	//	}
	//
	//	if !bytes.Equal(d.Digest, digest.Digest) {
	//		return nil, fmt.Errorf("stored and computed policy digest mismatch (computed: %x, stored: %x)", digest.Digest, d.Digest)
	//	}
	//}

	return digest.Digest, nil
}

type listBranchesContext struct {
	branches []string
	current  policyBranchPath
}

func (c *listBranchesContext) beginBranchNode() (treeWalkerBeginBranchFn, error) {
	return c.beginBranch, nil
}

func (c *listBranchesContext) beginBranch(path policyBranchPath) error {
	c.current = path
	return nil
}

func (c *listBranchesContext) completeBranch(done bool) error {
	c.branches = append(c.branches, string(c.current))
	return nil
}

func newListBranchesPolicyRunnerContext(runner *policyRunner, context *listBranchesContext) *policyRunnerContext {
	return newPolicyRunnerContext(
		newNullPolicySession(tpm2.HashAlgorithmSHA256),
		new(mockPolicyParams),
		new(mockResources),
		newTreeWalkerPolicyRunnerHelper(runner, tpm2.HashAlgorithmNull, treeWalkerModeRootTree, context.beginBranchNode, context.completeBranch),
	)
}

// Branches returns a list of every branch in this policy.
func (p *Policy) Branches() ([]string, error) {
	context := new(listBranchesContext)

	runner := new(policyRunner)
	runner.policyRunnerContext = newListBranchesPolicyRunnerContext(runner, context)

	element := &policyElement{
		Type: tpm2.CommandPolicyOR,
		Details: &policyElementDetails{
			OR: &policyORElement{
				Branches: policyBranches{{Policy: p.policy.Policy}},
			},
		},
	}
	if err := runner.run(policyElements{element}); err != nil {
		return nil, err
	}

	return context.branches, nil
}

// PolicyNVRequirement contains a description of a TPM2_PolicyNV assertion in a policy.
// If a policy is used for authorization of the NV index, the members of this can be used
// to inspect the requirements of that policy.
type PolicyNVRequirement struct {
	Auth      tpm2.Handle
	Index     NVIndex
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

type PolicyAuthorizationID struct {
	AuthName  tpm2.Name
	PolicyRef tpm2.Nonce
}

// PolicyBranchRequirements describes the requirements of a branch, which indicate the
// resources which must be supplied and authorized.
type PolicyBranchRequirements struct {
	NV        []PolicyNVRequirement   // Requirements for TPM2_PolicyNV assertions
	Signed    []PolicyAuthorizationID // TPM2_PolicySigned assertions
	Secret    []PolicyAuthorizationID // TPM2_PolicySecret assertions
	AuthValue bool                    // The branch contains a TPM2_PolicyAuthValue or TPM2_PolicyPassword assertion
}

func newPolicyBranchRequirements(report *policySessionReport) *PolicyBranchRequirements {
	out := new(PolicyBranchRequirements)
	for _, nv := range report.nv {
		out.NV = append(out.NV, PolicyNVRequirement{
			Auth:      nv.auth,
			Index:     nv.index,
			OperandB:  nv.operandB,
			Offset:    nv.offset,
			Operation: nv.operation,
		})
	}
	for _, signed := range report.signed {
		out.Signed = append(out.Signed, PolicyAuthorizationID{
			AuthName:  signed.authKey.Name(),
			PolicyRef: signed.policyRef,
		})
	}
	for _, secret := range report.secret {
		out.Secret = append(out.Secret, PolicyAuthorizationID{
			AuthName:  secret.authObject.Name(),
			PolicyRef: secret.policyRef,
		})
	}
	out.AuthValue = report.authValueNeeded
	return out
}

type branchRequirementsPolicyRunnerHelper struct {
	policyBranchSelectMixin
	runner *policyRunner
	state  tpmState
	usage  *PolicySessionUsage

	path      policyBranchPath
	remaining policyBranchPath

	candidates []candidateBranch
}

func newBranchRequirementsPolicyRunnerHelper(runner *policyRunner, state tpmState, params *PolicyBranchSelectParams) *branchRequirementsPolicyRunnerHelper {
	return &branchRequirementsPolicyRunnerHelper{
		runner:    runner,
		state:     state,
		remaining: policyBranchPath(params.Path),
		usage:     params.Usage,
	}
}

func (h *branchRequirementsPolicyRunnerHelper) cpHash(cpHash *policyCpHashElement) (tpm2.Digest, error) {
	return make(tpm2.Digest, h.runner.session().HashAlg()), nil
}

func (h *branchRequirementsPolicyRunnerHelper) nameHash(nameHash *policyNameHashElement) (tpm2.Digest, error) {
	return make(tpm2.Digest, h.runner.session().HashAlg()), nil
}

func (h *branchRequirementsPolicyRunnerHelper) handleBranches(branches policyBranches) error {
	next, remaining := h.remaining.PopNextComponent()
	if len(next) == 0 {
		filter := newPolicyBranchFilter(h.runner, h.state, h.usage)
		return filter.filterBranches(branches, policyBranchFilterModeGreedy, func(candidates []candidateBranch) error {
			if len(candidates) == 0 {
				return errors.New("no candidate branches")
			}
			h.candidates = candidates
			return nil
		})
	}

	h.remaining = remaining
	selected, err := h.selectBranch(branches, next)
	if err != nil {
		return err
	}

	name := policyBranchPath(branches[selected].Name)
	if len(name) == 0 {
		name = policyBranchPath(fmt.Sprintf("$[%d]", selected))
	}
	h.path = h.path.Concat(name)

	h.runner.pushElements(branches[selected].Policy)

	return nil
}

// BranchRequirements returns the requirements of a set of branches, which indicate the
// resources which must be supplied and authorized.
//
// The caller may explicitly select a branch via the Path argument of [PolicyExecuteParams].
// Alternatively, if a branch is not selected explicitly, the requirements for each candidate
// branch will be returned (see [Policy.Execute] for how candidate branches are filtered).
// TPM2_PolicyCounterTimer or TPM2_PolicyNvWritten assertions.
func (p *Policy) BranchRequirements(helper PolicyExecuteHelper, params *PolicyBranchSelectParams) (map[string]PolicyBranchRequirements, error) {
	if helper == nil {
		helper = new(nullPolicyExecuteHelper)
	}
	if params == nil {
		params = new(PolicyBranchSelectParams)
	}

	var report policySessionReport

	runner := new(policyRunner)
	runnerHelper := newBranchRequirementsPolicyRunnerHelper(runner, helper, params)
	runner.policyRunnerContext = newPolicyRunnerContext(
		&observingPolicySession{session: newNullPolicySession(tpm2.HashAlgorithmSHA256), report: &report},
		new(mockPolicyParams),
		new(mockResources),
		runnerHelper,
	)

	if err := runner.run(p.policy.Policy); err != nil {
		return nil, err
	}

	out := make(map[string]PolicyBranchRequirements)

	if len(runnerHelper.candidates) == 0 {
		req := newPolicyBranchRequirements(&report)
		out[string(runnerHelper.path)] = *req
	} else {
		for _, candidate := range runnerHelper.candidates {
			req := newPolicyBranchRequirements(report.append(&candidate.report))
			out[string(runnerHelper.path.Concat(candidate.path))] = *req
		}
	}

	return out, nil
}
