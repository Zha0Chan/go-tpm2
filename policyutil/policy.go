// Copyright 2023 Canonical Ltd.
// Licensed under the LGPLv3 with static-linking exception.
// See LICENCE file for details.

package policyutil

import (
	"bytes"
	"crypto"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"math"
	"reflect"
	"sort"
	"strings"
	"unicode/utf8"

	"github.com/canonical/go-tpm2"
	"github.com/canonical/go-tpm2/mu"
)

const (
	commandPolicyBranchNode tpm2.CommandCode = 0x20010171
)

var (
	// ErrMissingDigest is returned from [Policy.Execute] when a TPM2_PolicyCpHash or
	// TPM2_PolicyNameHash assertion is missing a digest for the selected session algorithm.
	ErrMissingDigest = errors.New("missing digest for session algorithm")
)

type paramKey [sha256.Size]byte

func policyParamKey(authName tpm2.Name, policyRef tpm2.Nonce) paramKey {
	h := crypto.SHA256.New()
	h.Write(authName)
	h.Write(policyRef)

	var key paramKey
	copy(key[:], h.Sum(nil))
	return key
}

// PolicyTicket corresponds to a ticket generated from a TPM2_PolicySigned or TPM2_PolicySecret
// assertion and is returned by [Policy.Execute]. Generated tickets can be supplied to
// [Policy.Execute] in the future in order to satisfy these assertions as long as they haven't
// expired.
type PolicyTicket struct {
	AuthName  tpm2.Name    // The name of the auth object associated with the corresponding assertion
	PolicyRef tpm2.Nonce   // The policy ref of the corresponding assertion
	CpHash    tpm2.Digest  // The cpHash supplied to the assertion that generated this ticket
	Timeout   tpm2.Timeout // The timeout returned by the assertion that generated this ticket

	// Ticket is the actual ticket returned by the TPM for the assertion that generated this ticket.
	// The Tag field indicates whether this was generated by TPM2_PolicySigned or TPM2_PolicySecret.
	Ticket *tpm2.TkAuth
}

// PolicySecretParams provides a way for an application to customize the cpHash and expiration
// arguments of a TPM2_PolicySecret assertion with the specified reference and for a resource
// with the specified name. These parameters aren't part of the policy because they aren't
// cryptographically bound to the policy digest and can be modified.
type PolicySecretParams struct {
	AuthName  tpm2.Name  // The name of the auth object associated with the corresponding TPM2_PolicySecret assertion
	PolicyRef tpm2.Nonce // The policy ref of the corresponding assertion
	CpHash    CpHash     // The command parameters to restrict the session usage to

	// Expiration specifies a timeout based on the absolute value of this field in seconds, after
	// which the authorization will expire. The timeout is measured from the time that the most
	// recent TPM nonce was generated for the session. This can be used to request a ticket that
	// can be used in a subsequent policy execution by specifying a negative value, in which case
	// this field and the CpHash field restrict the validity period and scope of the returned
	// ticket.
	Expiration int32
}

// AuthorizationNotFoundError is returned from [Policy.Execute] if the policy required a
// signed authorization for a TPM2_PolicySigned assertion, but one wasn't supplied and
// an appropriate ticket was also not supplied.
type AuthorizationNotFoundError struct {
	AuthName  tpm2.Name
	PolicyRef tpm2.Nonce
}

func (e *AuthorizationNotFoundError) Error() string {
	return fmt.Sprintf("missing signed authorization for assertion with authName: %#x, policyRef: %#x)", e.AuthName, e.PolicyRef)
}

// ResourceNotFoundError is returned from [Policy.Execute] if the policy required a resource
// with the indicated name but one wasn't supplied.
type ResourceNotFoundError tpm2.Name

func (e ResourceNotFoundError) Error() string {
	return fmt.Sprintf("missing resource with name %#x", tpm2.Name(e))
}

// SavedContext contains the context of a saved transient object and its name, and
// can be used to supply transient resources to [Policy.Execute].
type SavedContext struct {
	Name    tpm2.Name
	Context *tpm2.Context
}

// SaveAndFlushResource saves the context of the supplied transient resource, flushes it and
// returns a *SavedContext instance that can be supplied to [Policy.Execute].
func SaveAndFlushResource(tpm *tpm2.TPMContext, resource tpm2.ResourceContext) (*SavedContext, error) {
	name := resource.Name()
	context, err := tpm.ContextSave(resource)
	if err != nil {
		return nil, err
	}
	if err := tpm.FlushContext(resource); err != nil {
		return nil, err
	}
	return &SavedContext{Name: name, Context: context}, nil
}

// LoadableObject contains the data associated with an unloaded transient object, and
// can be used to supply transient resources to [Policy.Execute].
type LoadableObject struct {
	ParentName tpm2.Name
	Public     *tpm2.Public
	Private    tpm2.Private
}

// PolicyResources contains the resources that are required by [Policy.Execute].
type PolicyResources struct {
	// Loaded resources are resources that are already loaded in the TPM, such
	// as NV indices, persistent resources, or transient resources that have
	// already been loaded. Note that permanent or PCR resources do not need
	// to be explicitly supplied.
	Loaded []tpm2.ResourceContext

	// Saved resources are transient objects that have been previously loaded,
	// context saved and then flushed, and need to be context loaded with
	// TPM2_ContextLoad in order to use. These will be flushed after use.
	Saved []*SavedContext

	// Unloaded resources are transient objects that need to be loaded with
	// TPM2_Load in order to use. These will be flushed after use.
	Unloaded []*LoadableObject
}

// PolicyBranchName corresponds to the name of a branch. Valid names are UTF-8
// strings that start with characters other than '$'. A branch doesn't have to have
// a name, in which case it can be selected by its index.
type PolicyBranchName string

func (n PolicyBranchName) isValid() bool {
	if !utf8.ValidString(string(n)) {
		return false
	}
	if len(n) > 0 && n[0] == '$' {
		return false
	}
	return true
}

func (n PolicyBranchName) Marshal(w io.Writer) error {
	if !n.isValid() {
		return errors.New("invalid name")
	}
	_, err := mu.MarshalToWriter(w, []byte(n))
	return err
}

func (n *PolicyBranchName) Unmarshal(r io.Reader) error {
	var b []byte
	if _, err := mu.UnmarshalFromReader(r, &b); err != nil {
		return err
	}
	name := PolicyBranchName(b)
	if !name.isValid() {
		return errors.New("invalid name")
	}
	*n = name
	return nil
}

// PolicyBranchPath uniquely identifies an execution path through the branches in a
// profile, with each branch selector component being separated by a '/' character. A
// branch selector selects a branch at a node, and a branch can either be selected by
// its name (if it has one), or a numeric identifier of the form "$[n]" which selects
// a branch at a node using its index.
//
// The component "$auto" enables autoselection for a node, where a branch will be selected
// automatically. This only works for branches containing TPM2_PolicyPCR assertions
// where the assertion parameters match the current PCR values.
type PolicyBranchPath string

func (p PolicyBranchPath) popNextComponent() (next PolicyBranchPath, remaining PolicyBranchPath) {
	remaining = p
	for len(remaining) > 0 {
		s := strings.SplitN(string(remaining), "/", 2)
		remaining = ""
		if len(s) == 2 {
			remaining = PolicyBranchPath(s[1])
		}
		component := PolicyBranchPath(s[0])
		if len(component) > 0 {
			return component, remaining
		}
	}

	return "", ""
}

// PolicyExecuteParams contains parameters that are useful for executing a policy.
type PolicyExecuteParams struct {
	Resources            *PolicyResources             // Resources required by the policy
	SecretParams         []*PolicySecretParams        // Parameters for TPM2_PolicySecret assertions
	SignedAuthorizations []*PolicySignedAuthorization // Authorizations for TPM2_PolicySigned assertions
	Tickets              []*PolicyTicket              // Tickets for TPM2_PolicySecret and TPM2_PolicySigned assertions
	SelectedPath         PolicyBranchPath             // The selected path to execute
}

// PolicyResourceAuthorizer provides a way for an application to authorize resources
// that are used by a policy.
type PolicyResourceAuthorizer interface {
	// Authorize requests that the supplied context is prepared for use with the user auth role for
	// the corresponding resource. If the user auth role requires knowledge of the authorization
	// value, this should be set by the implementation. The implementation can also return an optional
	// session to use for authorization. If no session is returned, passphrase auth is used. Note
	// that the returned session will not be flushed if the AttrContinueSession attribute is set, or
	// an error occurs.
	//
	// This is required to support TPM2_PolicyNV and TPM2_PolicySecret.
	Authorize(resource tpm2.ResourceContext) (tpm2.SessionContext, error)
}

type policySession interface {
	HashAlg() tpm2.HashAlgorithmId

	PolicyNV(auth, index tpm2.ResourceContext, operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp, authAuthSession tpm2.SessionContext) error
	PolicySecret(authObject tpm2.ResourceContext, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, authObjectAuthSession tpm2.SessionContext) (tpm2.Timeout, *tpm2.TkAuth, error)
	PolicySigned(authKey tpm2.ResourceContext, includeNonceTPM bool, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, auth *tpm2.Signature) (tpm2.Timeout, *tpm2.TkAuth, error)
	PolicyAuthorize(approvedPolicy tpm2.Digest, policyRef tpm2.Nonce, keySign tpm2.Name, verified *tpm2.TkVerified) error
	PolicyAuthValue() error
	PolicyCommandCode(code tpm2.CommandCode) error
	PolicyCounterTimer(operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp) error
	PolicyCpHash(cpHashA tpm2.Digest) error
	PolicyNameHash(nameHash tpm2.Digest) error
	PolicyOR(pHashList tpm2.DigestList) error
	PolicyTicket(timeout tpm2.Timeout, cpHashA tpm2.Digest, policyRef tpm2.Nonce, authName tpm2.Name, ticket *tpm2.TkAuth) error
	PolicyPCR(pcrDigest tpm2.Digest, pcrs tpm2.PCRSelectionList) error
	PolicyDuplicationSelect(objectName, newParentName tpm2.Name, includeObject bool) error
	PolicyPassword() error
	PolicyNvWritten(writtenSet bool) error

	PolicyGetDigest() (tpm2.Digest, error)
}

type policyParams interface {
	secretParams(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySecretParams
	signedAuthorization(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySignedAuthorization
	ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket
}

type policyResourceContext interface {
	resource() tpm2.ResourceContext
	flush() error
}

type policyResources interface {
	loadHandle(handle tpm2.Handle) (tpm2.ResourceContext, error)
	loadName(name tpm2.Name) (policyResourceContext, error)
	loadExternal(pub *tpm2.Public) (policyResourceContext, error)

	authorize(context tpm2.ResourceContext) (tpm2.SessionContext, error)
}

// policyRunnerRestoreContext is a pseudo policy element that restores the
// context for a policy runner, and is used when computing branch or authorized
// policy digests.
type policyRunnerRestoreContext struct {
	runner  *policyRunner
	context *policyRunnerContext
}

func (*policyRunnerRestoreContext) name() string { return "restore runner context" }

func (e *policyRunnerRestoreContext) run(context policySessionContext) error {
	e.runner.policyRunnerContext = e.context
	return nil
}

type policyFlowHandler interface {
	handleBranches(branches policyBranches) error
	pushComputeContext(digest *taggedHash)
}

type policySessionContext interface {
	session() policySession
	params() policyParams
	resources() policyResources
	flowHandler() policyFlowHandler

	ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket
	addTicket(ticket *PolicyTicket)
}

type policyRunDispatcher interface {
	runElementsNext(elements []policyElementRunner)
}

// realPolicySession is an implementation of policySession that executes assertions
// on a TPM.
type realPolicySession struct {
	tpm           *tpm2.TPMContext
	policySession tpm2.SessionContext
	authorizer    PolicyResourceAuthorizer
	sessions      []tpm2.SessionContext
}

func newRealPolicySession(tpm *tpm2.TPMContext, policySession tpm2.SessionContext, sessions ...tpm2.SessionContext) *realPolicySession {
	return &realPolicySession{
		tpm:           tpm,
		policySession: policySession,
		sessions:      sessions}
}

func (s *realPolicySession) HashAlg() tpm2.HashAlgorithmId {
	return s.policySession.HashAlg()
}

func (s *realPolicySession) PolicyNV(auth, index tpm2.ResourceContext, operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp, authAuthSession tpm2.SessionContext) error {
	return s.tpm.PolicyNV(auth, index, s.policySession, operandB, offset, operation, authAuthSession, s.sessions...)
}

func (s *realPolicySession) PolicySecret(authObject tpm2.ResourceContext, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, authObjectAuthSession tpm2.SessionContext) (tpm2.Timeout, *tpm2.TkAuth, error) {
	return s.tpm.PolicySecret(authObject, s.policySession, cpHashA, policyRef, expiration, authObjectAuthSession, s.sessions...)
}

func (s *realPolicySession) PolicySigned(authKey tpm2.ResourceContext, includeNonceTPM bool, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, auth *tpm2.Signature) (tpm2.Timeout, *tpm2.TkAuth, error) {
	return s.tpm.PolicySigned(authKey, s.policySession, includeNonceTPM, cpHashA, policyRef, expiration, auth, s.sessions...)
}

func (s *realPolicySession) PolicyAuthorize(approvedPolicy tpm2.Digest, policyRef tpm2.Nonce, keySign tpm2.Name, verified *tpm2.TkVerified) error {
	return s.tpm.PolicyAuthorize(s.policySession, approvedPolicy, policyRef, keySign, verified, s.sessions...)
}

func (s *realPolicySession) PolicyAuthValue() error {
	return s.tpm.PolicyAuthValue(s.policySession, s.sessions...)
}

func (s *realPolicySession) PolicyCommandCode(code tpm2.CommandCode) error {
	return s.tpm.PolicyCommandCode(s.policySession, code, s.sessions...)
}

func (s *realPolicySession) PolicyCounterTimer(operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp) error {
	return s.tpm.PolicyCounterTimer(s.policySession, operandB, offset, operation, s.sessions...)
}

func (s *realPolicySession) PolicyCpHash(cpHashA tpm2.Digest) error {
	return s.tpm.PolicyCpHash(s.policySession, cpHashA, s.sessions...)
}

func (s *realPolicySession) PolicyNameHash(nameHash tpm2.Digest) error {
	return s.tpm.PolicyNameHash(s.policySession, nameHash, s.sessions...)
}

func (s *realPolicySession) PolicyOR(pHashList tpm2.DigestList) error {
	return s.tpm.PolicyOR(s.policySession, pHashList, s.sessions...)
}

func (s *realPolicySession) PolicyTicket(timeout tpm2.Timeout, cpHashA tpm2.Digest, policyRef tpm2.Nonce, authName tpm2.Name, ticket *tpm2.TkAuth) error {
	return s.tpm.PolicyTicket(s.policySession, timeout, cpHashA, policyRef, authName, ticket, s.sessions...)
}

func (s *realPolicySession) PolicyPCR(pcrDigest tpm2.Digest, pcrs tpm2.PCRSelectionList) error {
	return s.tpm.PolicyPCR(s.policySession, pcrDigest, pcrs, s.sessions...)
}

func (s *realPolicySession) PolicyDuplicationSelect(objectName, newParentName tpm2.Name, includeObject bool) error {
	return s.tpm.PolicyDuplicationSelect(s.policySession, objectName, newParentName, includeObject, s.sessions...)
}

func (s *realPolicySession) PolicyPassword() error {
	return s.tpm.PolicyPassword(s.policySession, s.sessions...)
}

func (s *realPolicySession) PolicyNvWritten(writtenSet bool) error {
	return s.tpm.PolicyNvWritten(s.policySession, writtenSet, s.sessions...)
}

func (s *realPolicySession) PolicyGetDigest() (tpm2.Digest, error) {
	return s.tpm.PolicyGetDigest(s.policySession, s.sessions...)
}

// realPolicyParams is an implementation of policyParams that provides real
// parameters.
type realPolicyParams struct {
	policySecretParams map[paramKey]*PolicySecretParams
	authorizations     map[paramKey]*PolicySignedAuthorization
	tickets            map[paramKey]*PolicyTicket
}

func newRealPolicyParams(params *PolicyExecuteParams) *realPolicyParams {
	out := &realPolicyParams{
		policySecretParams: make(map[paramKey]*PolicySecretParams),
		authorizations:     make(map[paramKey]*PolicySignedAuthorization),
		tickets:            make(map[paramKey]*PolicyTicket),
	}
	for _, param := range params.SecretParams {
		out.policySecretParams[policyParamKey(param.AuthName, param.PolicyRef)] = param
	}
	for _, auth := range params.SignedAuthorizations {
		if auth.Authorization == nil {
			continue
		}
		out.authorizations[policyParamKey(auth.Authorization.AuthKey.Name(), auth.Authorization.PolicyRef)] = auth
	}
	for _, ticket := range params.Tickets {
		out.tickets[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
	}

	return out
}

func (p *realPolicyParams) secretParams(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySecretParams {
	return p.policySecretParams[policyParamKey(authName, policyRef)]
}

func (p *realPolicyParams) signedAuthorization(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySignedAuthorization {
	return p.authorizations[policyParamKey(authName, policyRef)]
}

func (p *realPolicyParams) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	return p.tickets[policyParamKey(authName, policyRef)]
}

type policyResourceContextFlushable struct {
	rc  tpm2.ResourceContext
	tpm *tpm2.TPMContext
}

func newPolicyResourceContextFlushable(tpm *tpm2.TPMContext, context tpm2.ResourceContext) policyResourceContext {
	return &policyResourceContextFlushable{rc: context, tpm: tpm}
}

func (r *policyResourceContextFlushable) resource() tpm2.ResourceContext {
	return r.rc
}

func (r *policyResourceContextFlushable) flush() error {
	return r.tpm.FlushContext(r.rc)
}

type policyResourceContextNoFlush struct {
	rc tpm2.ResourceContext
}

func newPolicyResourceContextNonFlushable(context tpm2.ResourceContext) policyResourceContext {
	return &policyResourceContextNoFlush{rc: context}
}

func (r *policyResourceContextNoFlush) resource() tpm2.ResourceContext {
	return r.rc
}

func (r *policyResourceContextNoFlush) flush() error {
	return nil
}

// onlinePolicyResources is an implementation of policyResources that requires access
// to a TPM.
type onlinePolicyResources struct {
	tpm        *tpm2.TPMContext
	loaded     []tpm2.ResourceContext
	saved      []*SavedContext
	unloaded   []*LoadableObject
	authorizer PolicyResourceAuthorizer
	sessions   []tpm2.SessionContext
}

func newOnlinePolicyResources(tpm *tpm2.TPMContext, resources *PolicyResources, authorizer PolicyResourceAuthorizer, sessions ...tpm2.SessionContext) *onlinePolicyResources {
	if resources == nil {
		resources = new(PolicyResources)
	}

	return &onlinePolicyResources{
		tpm:        tpm,
		loaded:     resources.Loaded,
		saved:      resources.Saved,
		unloaded:   resources.Unloaded,
		authorizer: authorizer,
		sessions:   sessions,
	}
}

func (r *onlinePolicyResources) loadHandle(handle tpm2.Handle) (tpm2.ResourceContext, error) {
	switch handle.Type() {
	case tpm2.HandleTypePCR, tpm2.HandleTypePermanent:
		return r.tpm.GetPermanentContext(handle), nil
	default:
		return nil, fmt.Errorf("invalid handle type %v", handle.Type())
	}
}

func (r *onlinePolicyResources) loadName(name tpm2.Name) (policyResourceContext, error) {
	if !name.IsValid() {
		return nil, errors.New("invalid name")
	}
	if name.Type() == tpm2.NameTypeHandle && (name.Handle().Type() == tpm2.HandleTypePCR || name.Handle().Type() == tpm2.HandleTypePermanent) {
		return newPolicyResourceContextNonFlushable(r.tpm.GetPermanentContext(name.Handle())), nil
	}

	// Search already loaded resources
	for _, resource := range r.loaded {
		if !bytes.Equal(resource.Name(), name) {
			continue
		}

		return newPolicyResourceContextNonFlushable(resource), nil
	}

	// Search saved contexts
	for _, context := range r.saved {
		if !bytes.Equal(context.Name, name) {
			continue
		}

		hc, err := r.tpm.ContextLoad(context.Context)
		if err != nil {
			return nil, err
		}
		if !bytes.Equal(hc.Name(), name) {
			r.tpm.FlushContext(hc)
			return nil, fmt.Errorf("loaded context has the wrong name (got %#x, expected %#x)", hc.Name(), name)
		}
		resource, ok := hc.(tpm2.ResourceContext)
		if !ok {
			r.tpm.FlushContext(hc)
			return nil, fmt.Errorf("name %#x associated with a context of the wrong type", name)
		}

		return newPolicyResourceContextFlushable(r.tpm, resource), nil
	}

	// Search loadable objects
	for _, object := range r.unloaded {
		if !bytes.Equal(object.Public.Name(), name) {
			continue
		}

		parent, err := r.loadName(object.ParentName)
		if err != nil {
			return nil, fmt.Errorf("cannot load parent for object with name %#x: %w", name, err)
		}
		defer parent.flush()

		session, err := r.authorize(parent.resource())
		if err != nil {
			return nil, fmt.Errorf("cannot authorize parent with name %#x: %w", parent.resource().Name(), err)
		}

		resource, err := r.tpm.Load(parent.resource(), object.Private, object.Public, session, r.sessions...)
		if err != nil {
			return nil, err
		}

		if context, err := r.tpm.ContextSave(resource); err == nil {
			r.saved = append(r.saved, &SavedContext{Name: name, Context: context})
		}

		return newPolicyResourceContextFlushable(r.tpm, resource), nil
	}

	// Search persistent and NV index handles
	handles, err := r.tpm.GetCapabilityHandles(tpm2.HandleTypePersistent.BaseHandle(), math.MaxUint32, r.sessions...)
	if err != nil {
		return nil, err
	}
	nvHandles, err := r.tpm.GetCapabilityHandles(tpm2.HandleTypeNVIndex.BaseHandle(), math.MaxUint32, r.sessions...)
	if err != nil {
		return nil, err
	}
	handles = append(handles, nvHandles...)
	for _, handle := range handles {
		resource, err := r.tpm.NewResourceContext(handle, r.sessions...)
		if tpm2.IsResourceUnavailableError(err, handle) {
			continue
		}
		if err != nil {
			return nil, err
		}
		if !bytes.Equal(resource.Name(), name) {
			continue
		}

		r.loaded = append(r.loaded, resource)
		return newPolicyResourceContextNonFlushable(resource), nil
	}

	return nil, ResourceNotFoundError(name)
}

func (r *onlinePolicyResources) loadExternal(public *tpm2.Public) (policyResourceContext, error) {
	rc, err := r.tpm.LoadExternal(nil, public, tpm2.HandleOwner, r.sessions...)
	if err != nil {
		return nil, err
	}
	return newPolicyResourceContextFlushable(r.tpm, rc), nil
}

func (r *onlinePolicyResources) authorize(context tpm2.ResourceContext) (tpm2.SessionContext, error) {
	if r.authorizer == nil {
		return nil, errors.New("no authorizer")
	}
	return r.authorizer.Authorize(context)
}

type policyBranchAutoSelector struct {
	tpm        *tpm2.TPMContext
	sessionAlg tpm2.HashAlgorithmId
	pcrs       tpm2.PCRSelectionList
	pcrValues  tpm2.PCRValues
	sessions   []tpm2.SessionContext
}

func newPolicyBranchAutoSelector(tpm *tpm2.TPMContext, sessionAlg tpm2.HashAlgorithmId, sessions ...tpm2.SessionContext) *policyBranchAutoSelector {
	return &policyBranchAutoSelector{
		tpm:        tpm,
		sessionAlg: sessionAlg,
		sessions:   sessions,
	}
}

func (s *policyBranchAutoSelector) collectPCRSelectionList(branches policyBranches) {
	s.pcrs = nil
	for _, branch := range branches {
		for _, element := range branch.Policy {
			if element.Type != tpm2.CommandPolicyPCR {
				continue
			}

			values, err := element.Details.PCR.pcrValues()
			if err != nil {
				continue
			}
			pcrs, err := values.SelectionList()
			if err != nil {
				continue
			}

			s.pcrs = s.pcrs.MustMerge(pcrs)
		}
	}

	s.pcrValues = nil
}

func (s *policyBranchAutoSelector) ensureCurrentPCRValues() error {
	_, values, err := s.tpm.PCRRead(s.pcrs, s.sessions...)
	if err != nil {
		return err
	}
	s.pcrValues = values
	return nil
}

func (s *policyBranchAutoSelector) checkPolicyPCR(pcr *policyPCR) (bool, error) {
	if err := s.ensureCurrentPCRValues(); err != nil {
		return false, err
	}

	values, err := pcr.pcrValues()
	if err != nil {
		return false, nil
	}
	pcrs, pcrDigest, err := ComputePCRDigestFromAllValues(s.sessionAlg, values)
	if err != nil {
		return false, nil
	}

	currentDigest, err := ComputePCRDigest(s.sessionAlg, pcrs, s.pcrValues)
	if err != nil {
		return false, fmt.Errorf("cannot compute PCR digest from current values: %w", err)
	}

	return bytes.Equal(pcrDigest, currentDigest), nil
}

func (s *policyBranchAutoSelector) checkBranchValid(branch *policyBranch) (valid bool, err error) {
	for i, element := range branch.Policy {
		switch element.Type {
		case tpm2.CommandPolicyPCR:
			valid, err = s.checkPolicyPCR(element.Details.PCR)
		}
		if err != nil {
			return false, fmt.Errorf("cannot check element %d: %w", i, err)
		}
		if !valid {
			return false, nil
		}
	}

	return true, nil
}

func (s *policyBranchAutoSelector) run(branches policyBranches) (int, error) {
	s.collectPCRSelectionList(branches)

	for i, branch := range branches {
		valid, err := s.checkBranchValid(&branch)
		if err != nil {
			return -1, fmt.Errorf("cannot check whether branch %d can be selected: %w", i, err)
		}
		if valid {
			return i, nil
		}
	}

	return -1, nil
}

type realPolicyFlowHandler struct {
	tpm           *tpm2.TPMContext
	runner        *policyRunner
	policySession tpm2.SessionContext
	current       PolicyBranchPath
	remaining     PolicyBranchPath
	sessions      []tpm2.SessionContext
}

func newRealPolicyFlowHandler(tpm *tpm2.TPMContext, runner *policyRunner, policySession tpm2.SessionContext, path PolicyBranchPath, sessions ...tpm2.SessionContext) *realPolicyFlowHandler {
	return &realPolicyFlowHandler{
		tpm:           tpm,
		runner:        runner,
		policySession: policySession,
		current:       "/",
		remaining:     path,
		sessions:      sessions,
	}
}

func (h *realPolicyFlowHandler) tryAutoSelectBranch(branches policyBranches) (int, error) {
	selector := newPolicyBranchAutoSelector(h.tpm, h.policySession.HashAlg(), h.sessions...)
	return selector.run(branches)
}

func (h *realPolicyFlowHandler) handleBranches(branches policyBranches) error {
	// select a branch first
	next, remaining := h.remaining.popNextComponent()

	h.current = PolicyBranchPath(strings.Join([]string{string(h.current), string(next)}, "/"))
	h.remaining = remaining

	var selected int
	var err error
	switch {
	case len(next) == 0:
		// no branch explictly selected - try to autoselect first
		selected, err = h.tryAutoSelectBranch(branches)
		if err != nil {
			return fmt.Errorf("cannot autoselect branch: %w", err)
		}
		if selected == -1 {
			return errors.New("cannot select branch: no more path components")
		}
	case next == "$auto":
		// attempt autoselect
		selected, err = h.tryAutoSelectBranch(branches)
		if err != nil {
			return fmt.Errorf("cannot autoselect branch: %w", err)
		}
		if selected == -1 {
			return errors.New("cannot autoselect branch: no branch is valid for current state")
		}
	case next[0] == '$':
		// select branch by index
		if _, err := fmt.Sscanf(string(next), "$[%d]", &selected); err != nil {
			return fmt.Errorf("cannot select branch: badly formatted path component \"%s\": %w", next, err)
		}
		if selected < 0 || selected >= len(branches) {
			return fmt.Errorf("cannot select branch: selected path %d out of range", selected)
		}
	default:
		// select branch by name
		selected = -1
		for i, branch := range branches {
			if len(branch.Name) == 0 {
				continue
			}
			if branch.Name == PolicyBranchName(next) {
				selected = i
				break
			}
		}
		if selected == -1 {
			return fmt.Errorf("cannot select branch: no branch with name \"%s\"", next)
		}
	}

	if selected == -1 {
		// the switch branches should have returned a specific error already
		panic("not reached")
	}

	// we've selected a branch

	context := &policyBranchNodeContext{selected: selected}

	var elements []policyElementRunner

	// queue elements to obtain the digest for each branch. This is done asynchronously
	// because they may have to descend in to each branch to compute the digest
	for _, branch := range branches {
		branch := branch
		elements = append(elements, &policyCollectBranchDigest{
			context:    context,
			branch:     &branch,
			dispatcher: h.runner,
		})
	}

	// queue the element that actually runs the selected branch
	elements = append(elements, &policyBranchRun{
		context:    context,
		branch:     branches[selected].Policy,
		dispatcher: h.runner,
	})

	h.runner.runElementsNext(elements)
	return nil
}

func (h *realPolicyFlowHandler) pushComputeContext(digest *taggedHash) {
	oldContext := h.runner.policyRunnerContext
	h.runner.policyRunnerContext = newComputePolicyRunnerContext(h.runner, digest)

	h.runner.runElementsNext([]policyElementRunner{
		&policyRunnerRestoreContext{
			runner:  h.runner,
			context: oldContext,
		},
	})
}

type policyElementRunner interface {
	name() string
	run(context policySessionContext) error
}

type taggedHash struct {
	HashAlg tpm2.HashAlgorithmId
	Digest  tpm2.Digest
}

func (h taggedHash) Marshal(w io.Writer) error {
	ta := tpm2.MakeTaggedHash(h.HashAlg, h.Digest)
	_, err := mu.MarshalToWriter(w, ta)
	return err
}

func (h *taggedHash) Unmarshal(r io.Reader) error {
	var ta tpm2.TaggedHash
	if _, err := mu.UnmarshalFromReader(r, &ta); err != nil {
		return err
	}

	if ta.HashAlg != tpm2.HashAlgorithmNull && !ta.HashAlg.IsValid() {
		return errors.New("invalid digest algorithm")
	}

	*h = taggedHash{
		HashAlg: ta.HashAlg,
		Digest:  ta.Digest()}
	return nil
}

type taggedHashList []taggedHash

type policyNV struct {
	NvIndex   *tpm2.NVPublic
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (*policyNV) name() string { return "TPM2_PolicyNV assertion" }

func (e *policyNV) run(context policySessionContext) error {
	nvIndex, err := tpm2.NewNVIndexResourceContextFromPub(e.NvIndex)
	if err != nil {
		return fmt.Errorf("cannot create nvIndex context: %w", err)
	}

	auth := nvIndex
	switch {
	default:
	case e.NvIndex.Attrs&tpm2.AttrNVOwnerRead != 0:
		auth, err = context.resources().loadHandle(tpm2.HandleOwner)
	case e.NvIndex.Attrs&tpm2.AttrNVPPRead != 0:
		auth, err = context.resources().loadHandle(tpm2.HandlePlatform)
	}
	if err != nil {
		return fmt.Errorf("cannot create auth context: %w", err)
	}

	authContextAuthSession, err := context.resources().authorize(auth)
	if err != nil {
		return fmt.Errorf("cannot authorize auth object: %w", err)
	}

	return context.session().PolicyNV(auth, nvIndex, e.OperandB, e.Offset, e.Operation, authContextAuthSession)
}

type policySecret struct {
	AuthObjectName tpm2.Name
	PolicyRef      tpm2.Nonce
}

func (*policySecret) name() string { return "TPM2_PolicySecret assertion" }

func (e *policySecret) run(context policySessionContext) error {
	if ticket := context.ticket(e.AuthObjectName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySecret
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySecret
		case err != nil:
			return err
		default:
			// The ticket was accepted
			return nil
		}
	}

	params := context.params().secretParams(e.AuthObjectName, e.PolicyRef)
	if params == nil {
		var nilParams PolicySecretParams
		params = &nilParams
	}

	var cpHashA tpm2.Digest
	if params.CpHash != nil {
		var err error
		cpHashA, err = params.CpHash.Digest(context.session().HashAlg())
		if err != nil {
			return fmt.Errorf("cannot obtain cpHashA: %w", err)
		}
	}

	authObject, err := context.resources().loadName(e.AuthObjectName)
	if err != nil {
		return fmt.Errorf("cannot create authObject context: %w", err)
	}
	defer authObject.flush()

	authObjectAuthSession, err := context.resources().authorize(authObject.resource())
	if err != nil {
		return fmt.Errorf("cannot authorize authObject: %w", err)
	}

	timeout, ticket, err := context.session().PolicySecret(authObject.resource(), cpHashA, e.PolicyRef, params.Expiration, authObjectAuthSession)
	if err != nil {
		return err
	}

	context.addTicket(&PolicyTicket{
		AuthName:  e.AuthObjectName,
		PolicyRef: e.PolicyRef,
		CpHash:    cpHashA,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policySigned struct {
	AuthKeyName tpm2.Name
	PolicyRef   tpm2.Nonce
}

func (*policySigned) name() string { return "TPM2_PolicySigned assertion" }

func (e *policySigned) run(context policySessionContext) error {
	if ticket := context.ticket(e.AuthKeyName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySigned
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySigned
		case err != nil:
			return err
		default:
			// The ticket was accepted
			return nil
		}
	}

	auth := context.params().signedAuthorization(e.AuthKeyName, e.PolicyRef)
	if auth == nil {
		return &AuthorizationNotFoundError{AuthName: e.AuthKeyName, PolicyRef: e.PolicyRef}
	}

	authKey, err := context.resources().loadExternal(auth.Authorization.AuthKey)
	if err != nil {
		return fmt.Errorf("cannot create authKey context: %w", err)
	}
	defer authKey.flush()

	includeNonceTPM := false
	if len(auth.NonceTPM) > 0 {
		includeNonceTPM = true
	}

	timeout, ticket, err := context.session().PolicySigned(authKey.resource(), includeNonceTPM, auth.CpHash, e.PolicyRef, auth.Expiration, auth.Authorization.Signature)
	if err != nil {
		return err
	}

	context.addTicket(&PolicyTicket{
		AuthName:  authKey.resource().Name(),
		PolicyRef: e.PolicyRef,
		CpHash:    auth.CpHash,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policyAuthValue struct{}

func (*policyAuthValue) name() string { return "TPM2_PolicyAuthValue assertion" }

func (*policyAuthValue) run(context policySessionContext) error {
	return context.session().PolicyAuthValue()
}

type policyCommandCode struct {
	CommandCode tpm2.CommandCode
}

func (*policyCommandCode) name() string { return "TPM2_PolicyCommandCode assertion" }

func (e *policyCommandCode) run(context policySessionContext) error {
	return context.session().PolicyCommandCode(e.CommandCode)
}

type policyCounterTimer struct {
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (*policyCounterTimer) name() string { return "TPM2_PolicyCounterTimer assertion" }

func (e *policyCounterTimer) run(context policySessionContext) error {
	return context.session().PolicyCounterTimer(e.OperandB, e.Offset, e.Operation)
}

type policyCpHash struct {
	Digests taggedHashList
}

func (*policyCpHash) name() string { return "TPM2_PolicyCpHash assertion" }

func (e *policyCpHash) run(context policySessionContext) error {
	var cpHashA tpm2.Digest
	for _, digest := range e.Digests {
		if digest.HashAlg != context.session().HashAlg() {
			continue
		}
		cpHashA = digest.Digest
		break
	}
	if cpHashA == nil {
		return ErrMissingDigest
	}
	return context.session().PolicyCpHash(cpHashA)
}

type policyNameHash struct {
	Digests taggedHashList
}

func (*policyNameHash) name() string { return "TPM2_PolicyNameHash assertion" }

func (e *policyNameHash) run(context policySessionContext) error {
	var nameHash tpm2.Digest
	for _, digest := range e.Digests {
		if digest.HashAlg != context.session().HashAlg() {
			continue
		}
		nameHash = digest.Digest
		break
	}
	if nameHash == nil {
		return ErrMissingDigest
	}
	return context.session().PolicyNameHash(nameHash)
}

type policyBranch struct {
	Name          PolicyBranchName
	PolicyDigests taggedHashList
	Policy        policyElements
}

type policyBranches []policyBranch

type policyBranchNode struct {
	Branches policyBranches
}

func (*policyBranchNode) name() string { return "branch node" }

func (e *policyBranchNode) run(context policySessionContext) error {
	return context.flowHandler().handleBranches(e.Branches)
}

type policyBranchNodeContext struct {
	currentDigest tpm2.Digest
	digests       tpm2.DigestList
	selected      int
}

func (c *policyBranchNodeContext) ensureCurrentDigest(session policySession) error {
	if len(c.currentDigest) == session.HashAlg().Size() {
		return nil
	}

	currentDigest, err := session.PolicyGetDigest()
	if err != nil {
		return err
	}
	c.currentDigest = currentDigest
	return nil
}

// policyCollectBranchDigest is a pseudo policy element that obtains the digest
// for a branch, either from the stored value or by computing it.
type policyCollectBranchDigest struct {
	context    *policyBranchNodeContext
	branch     *policyBranch
	dispatcher policyRunDispatcher
}

func (*policyCollectBranchDigest) name() string { return "collect branch digest" }

func (e *policyCollectBranchDigest) run(context policySessionContext) error {
	// see if the branch has a stored value for the current algorithm
	for _, digest := range e.branch.PolicyDigests {
		if digest.HashAlg != context.session().HashAlg() {
			continue
		}

		// we have a digest, so update the context and we're done.
		e.context.digests = append(e.context.digests, digest.Digest)
		return nil
	}

	// we need to compute the digest, so ensure we have the current session
	// digest.
	if err := e.context.ensureCurrentDigest(context.session()); err != nil {
		return err
	}

	// push a new run context that will consume the policy assertions for this
	// branch so that we can compute its digest.
	digest := &taggedHash{
		HashAlg: context.session().HashAlg(),
		Digest:  make(tpm2.Digest, context.session().HashAlg().Size()),
	}
	copy(digest.Digest, e.context.currentDigest)
	context.flowHandler().pushComputeContext(digest)

	var elements []policyElementRunner

	// queue the elements for this branch
	for _, element := range e.branch.Policy {
		elements = append(elements, element)
	}

	// queue a final element to update the branch node context with the
	// computed digest.
	elements = append(elements, &policyCommitBranchDigest{
		context: e.context,
		digest:  digest,
	})

	e.dispatcher.runElementsNext(elements)
	return nil
}

// policyCommitBranchDigest is a pseudo policy element that updates a branch
// node context with the digest computed for a branch.
type policyCommitBranchDigest struct {
	context *policyBranchNodeContext
	digest  *taggedHash
}

func (*policyCommitBranchDigest) name() string { return "commit branch digest" }

func (e *policyCommitBranchDigest) run(context policySessionContext) error {
	e.context.digests = append(e.context.digests, e.digest.Digest)
	return nil
}

// policyBranchRun is a pseudo policy element that executes the elements of
// a selected branch and the subsequent TPM2_PolicyOR assertions.
type policyBranchRun struct {
	context    *policyBranchNodeContext
	branch     policyElements
	dispatcher policyRunDispatcher
}

func (*policyBranchRun) name() string { return "run branch" }

func (e *policyBranchRun) run(context policySessionContext) error {
	var elements []policyElementRunner
	for _, element := range e.branch {
		elements = append(elements, element)
	}

	tree, err := newPolicyOrTree(context.session().HashAlg(), e.context.digests)
	if err != nil {
		return fmt.Errorf("cannot compute PolicyOR tree: %w", err)
	}
	elements = append(elements, tree.selectBranch(e.context.selected)...)

	e.dispatcher.runElementsNext(elements)
	return nil
}

type policyOR struct {
	HashList []taggedHashList
}

func (*policyOR) name() string { return "TPM2_PolicyOR assertion" }

func (e *policyOR) run(context policySessionContext) error {
	var pHashList tpm2.DigestList
	for i, h := range e.HashList {
		found := false
		for _, digest := range h {
			if digest.HashAlg != context.session().HashAlg() {
				continue
			}
			pHashList = append(pHashList, digest.Digest)
			found = true
			break
		}
		if !found {
			return fmt.Errorf("cannot process digest at index %d: %w", i, ErrMissingDigest)
		}
	}

	return context.session().PolicyOR(pHashList)
}

type pcrValue struct {
	PCR    tpm2.Handle
	Digest taggedHash
}

type pcrValueList []pcrValue

type policyPCR struct {
	PCRs pcrValueList
}

func (*policyPCR) name() string { return "TPM2_PolicyPCR assertion" }

func (e *policyPCR) run(context policySessionContext) error {
	values, err := e.pcrValues()
	if err != nil {
		return err
	}
	pcrs, pcrDigest, err := ComputePCRDigestFromAllValues(context.session().HashAlg(), values)
	if err != nil {
		return fmt.Errorf("cannot compute PCR digest: %w", err)
	}
	return context.session().PolicyPCR(pcrDigest, pcrs)
}

func (e *policyPCR) pcrValues() (tpm2.PCRValues, error) {
	values := make(tpm2.PCRValues)
	for i, value := range e.PCRs {
		if value.PCR.Type() != tpm2.HandleTypePCR {
			return nil, fmt.Errorf("invalid PCR handle at index %d", i)
		}
		if err := values.SetValue(value.Digest.HashAlg, int(value.PCR), value.Digest.Digest); err != nil {
			return nil, fmt.Errorf("invalid PCR value at index %d: %w", i, err)
		}
	}
	return values, nil
}

type policyDuplicationSelect struct {
	Object        tpm2.Name
	NewParent     tpm2.Name
	IncludeObject bool
}

func (*policyDuplicationSelect) name() string { return "TPM2_PolicyDuplicationSelect assertion" }

func (e *policyDuplicationSelect) run(context policySessionContext) error {
	return context.session().PolicyDuplicationSelect(e.Object, e.NewParent, e.IncludeObject)
}

type policyPassword struct{}

func (*policyPassword) name() string { return "TPM2_PolicyPassword assertion" }

func (*policyPassword) run(context policySessionContext) error {
	return context.session().PolicyPassword()
}

type policyNvWritten struct {
	WrittenSet bool
}

func (*policyNvWritten) name() string { return "TPM2_PolicyNvWritten assertion" }

func (e *policyNvWritten) run(context policySessionContext) error {
	return context.session().PolicyNvWritten(e.WrittenSet)
}

type policyElementDetails struct {
	NV                *policyNV
	Secret            *policySecret
	Signed            *policySigned
	AuthValue         *policyAuthValue
	CommandCode       *policyCommandCode
	CounterTimer      *policyCounterTimer
	CpHash            *policyCpHash
	NameHash          *policyNameHash
	OR                *policyOR
	PCR               *policyPCR
	DuplicationSelect *policyDuplicationSelect
	Password          *policyPassword
	NvWritten         *policyNvWritten

	BranchNode *policyBranchNode
}

func (d *policyElementDetails) Select(selector reflect.Value) interface{} {
	switch selector.Interface().(tpm2.CommandCode) {
	case tpm2.CommandPolicyNV:
		return &d.NV
	case tpm2.CommandPolicySecret:
		return &d.Secret
	case tpm2.CommandPolicySigned:
		return &d.Signed
	case tpm2.CommandPolicyAuthValue:
		return &d.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return &d.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return &d.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return &d.CpHash
	case tpm2.CommandPolicyNameHash:
		return &d.NameHash
	case tpm2.CommandPolicyOR:
		return &d.OR
	case tpm2.CommandPolicyPCR:
		return &d.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return &d.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return &d.Password
	case tpm2.CommandPolicyNvWritten:
		return &d.NvWritten
	case commandPolicyBranchNode:
		return &d.BranchNode
	default:
		return nil
	}
}

type policyElement struct {
	Type    tpm2.CommandCode
	Details *policyElementDetails
}

func (e *policyElement) runner() policyElementRunner {
	switch e.Type {
	case tpm2.CommandPolicyNV:
		return e.Details.NV
	case tpm2.CommandPolicySecret:
		return e.Details.Secret
	case tpm2.CommandPolicySigned:
		return e.Details.Signed
	case tpm2.CommandPolicyAuthValue:
		return e.Details.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return e.Details.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return e.Details.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return e.Details.CpHash
	case tpm2.CommandPolicyNameHash:
		return e.Details.NameHash
	case tpm2.CommandPolicyOR:
		return e.Details.OR
	case tpm2.CommandPolicyPCR:
		return e.Details.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return e.Details.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return e.Details.Password
	case tpm2.CommandPolicyNvWritten:
		return e.Details.NvWritten
	case commandPolicyBranchNode:
		return e.Details.BranchNode
	default:
		panic("invalid type")
	}
}

func (e *policyElement) name() string {
	return e.runner().name()
}

func (e *policyElement) run(context policySessionContext) error {
	return e.runner().run(context)
}

type policyElements []*policyElement

type policy struct {
	Policy policyElements
}

// Policy corresponds to an authorization policy. It can be serialized with
// [github.com/canonical/go-tpm2/mu].
type Policy struct {
	policy policy
}

// Marshal implements [mu.CustomMarshaller.Marshal].
func (p Policy) Marshal(w io.Writer) error {
	_, err := mu.MarshalToWriter(w, p.policy)
	return err
}

// Unmarshal implements [mu.CustomMarshaller.Unarshal].
func (p *Policy) Unmarshal(r io.Reader) error {
	_, err := mu.UnmarshalFromReader(r, &p.policy)
	return err
}

type policyRunnerContext struct {
	policySession     policySession
	policyParams      policyParams
	policyResources   policyResources
	policyFlowHandler policyFlowHandler

	tickets map[paramKey]*PolicyTicket
}

func newPolicyRunnerContext(session policySession, params policyParams, resources policyResources, flowHandler policyFlowHandler) *policyRunnerContext {
	return &policyRunnerContext{
		policySession:     session,
		policyParams:      params,
		policyResources:   resources,
		policyFlowHandler: flowHandler,
		tickets:           make(map[paramKey]*PolicyTicket),
	}
}

func newRealPolicyRunnerContext(tpm *tpm2.TPMContext, runner *policyRunner, policySession tpm2.SessionContext, params *PolicyExecuteParams, authorizer PolicyResourceAuthorizer, sessions ...tpm2.SessionContext) *policyRunnerContext {
	if params == nil {
		params = new(PolicyExecuteParams)
	}

	return newPolicyRunnerContext(
		newRealPolicySession(tpm, policySession, sessions...),
		newRealPolicyParams(params),
		newOnlinePolicyResources(tpm, params.Resources, authorizer, sessions...),
		newRealPolicyFlowHandler(tpm, runner, policySession, params.SelectedPath, sessions...),
	)
}

type policyRunner struct {
	*policyRunnerContext
	elements []policyElementRunner
}

func (r *policyRunner) session() policySession {
	return r.policySession
}

func (r *policyRunner) params() policyParams {
	return r.policyParams
}

func (r *policyRunner) resources() policyResources {
	return r.policyResources
}

func (r *policyRunner) flowHandler() policyFlowHandler {
	return r.policyFlowHandler
}

func (r *policyRunner) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	if ticket, exists := r.tickets[policyParamKey(authName, policyRef)]; exists {
		return ticket
	}
	return r.policyParams.ticket(authName, policyRef)
}

func (r *policyRunner) addTicket(ticket *PolicyTicket) {
	if ticket.Ticket == nil || (ticket.Ticket.Hierarchy == tpm2.HandleNull && len(ticket.Ticket.Digest) == 0) {
		// skip null tickets
		return
	}
	r.tickets[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
}

func (r *policyRunner) runElementsNext(elements []policyElementRunner) {
	r.elements = append(elements, r.elements...)
}

func (r *policyRunner) run(policy policyElements) error {
	var elements []policyElementRunner
	for _, element := range policy {
		elements = append(elements, element)
	}
	r.elements = elements

	for len(r.elements) > 0 {
		element := r.elements[0]
		r.elements = r.elements[1:]

		if err := element.run(r); err != nil {
			return fmt.Errorf("cannot process %s: %w", element.name(), err)
		}
	}

	return nil
}

// Execute runs this policy using the supplied TPM context and on the supplied policy session.
//
// The caller may supply additional parameters via the PolicyExecuteParams struct. This can contain
// parameters for TPM2_PolicySecret assertions, signed authorizations for TPM2_PolicySigned
// assertions, or tickets to satisfy TPM2_PolicySecret or TPM2_PolicySigned assertions. Each of
// these parameters are associated with a policy assertion by a name and policy reference.
//
// Resources required by a policy are also supplied via the PolicyExecuteParams struct. These can
// either be supplied as already loaded resources, or saved contexts or unloaded objects for resources
// that are transient objects. If a resource can not be found in the parameters supplied, this
// function will search the TPM's active persistent and NV index handles.
//
// Some policy assertions require authorization with the user auth role for some resources. An
// implementation of PolicyResourceAuthorizer must be supplied for this.
//
// On success, the supplied policy session may be used for authorization in a context that requires
// that this policy is satisfied. It will also return a list of tickets generated by any assertions.
func (p *Policy) Execute(tpm *tpm2.TPMContext, policySession tpm2.SessionContext, params *PolicyExecuteParams, authorizer PolicyResourceAuthorizer, sessions ...tpm2.SessionContext) ([]*PolicyTicket, error) {
	runner := new(policyRunner)
	runner.policyRunnerContext = newRealPolicyRunnerContext(tpm, runner, policySession, params, authorizer, sessions...)
	if err := runner.run(p.policy.Policy); err != nil {
		return nil, err
	}

	var tickets []*PolicyTicket
	for _, ticket := range runner.tickets {
		tickets = append(tickets, ticket)
	}

	return tickets, nil
}

type policyValidateBranch struct {
	context    *policyBranchNodeContext
	branch     *policyBranch
	dispatcher policyRunDispatcher
}

func (*policyValidateBranch) name() string { return "validate branch" }

func (e *policyValidateBranch) run(context policySessionContext) error {
	if err := e.context.ensureCurrentDigest(context.session()); err != nil {
		return err
	}

	digest := &taggedHash{
		HashAlg: context.session().HashAlg(),
		Digest:  make(tpm2.Digest, context.session().HashAlg().Size()),
	}
	copy(digest.Digest, e.context.currentDigest)
	context.flowHandler().pushComputeContext(digest)

	var elements []policyElementRunner

	for _, element := range e.branch.Policy {
		elements = append(elements, element)
	}

	elements = append(elements, &policyValidateBranchComplete{
		context: e.context,
		branch:  e.branch,
		digest:  digest,
	})

	e.dispatcher.runElementsNext(elements)
	return nil
}

type policyValidateBranchComplete struct {
	context *policyBranchNodeContext
	branch  *policyBranch
	digest  *taggedHash
}

func (*policyValidateBranchComplete) name() string { return "compute validate branch" }

func (e *policyValidateBranchComplete) run(context policySessionContext) error {
	for _, d := range e.branch.PolicyDigests {
		if d.HashAlg != e.digest.HashAlg {
			continue
		}

		if !bytes.Equal(d.Digest, e.digest.Digest) {
			return fmt.Errorf("stored and computed branch digest mismatch (computed: %x, stored: %x)", e.digest.Digest, d.Digest)
		}
	}

	e.context.digests = append(e.context.digests, e.digest.Digest)
	return nil
}

type validatePolicyFlowHandler struct {
	runner *policyRunner
}

func newValidatePolicyFlowHandler(runner *policyRunner) *validatePolicyFlowHandler {
	return &validatePolicyFlowHandler{runner: runner}
}

func (h *validatePolicyFlowHandler) handleBranches(branches policyBranches) error {
	context := new(policyBranchNodeContext)

	var elements []policyElementRunner
	for _, branch := range branches {
		branch := branch
		elements = append(elements, &policyValidateBranch{
			context:    context,
			branch:     &branch,
			dispatcher: h.runner,
		})
	}

	elements = append(elements, &policyBranchRun{
		context:    context,
		dispatcher: h.runner,
	})

	h.runner.runElementsNext(elements)
	return nil
}

func (h *validatePolicyFlowHandler) pushComputeContext(digest *taggedHash) {
	oldContext := h.runner.policyRunnerContext
	h.runner.policyRunnerContext = newPolicyRunnerContext(
		newComputePolicySessionContext(digest),
		oldContext.policyParams,
		oldContext.policyResources,
		oldContext.policyFlowHandler,
	)

	h.runner.runElementsNext([]policyElementRunner{
		&policyRunnerRestoreContext{
			runner:  h.runner,
			context: oldContext,
		},
	})
}

func newValidatePolicyRunnerContext(runner *policyRunner, digest *taggedHash) *policyRunnerContext {
	external := make(map[*tpm2.Public]tpm2.Name)
	return newPolicyRunnerContext(
		newComputePolicySessionContext(digest),
		newMockPolicyParams(external),
		newOfflinePolicyResources(external),
		newValidatePolicyFlowHandler(runner),
	)
}

// Validate performs some checking of every element in the policy, and
// verifies that every branch is consistent with the stored digests where
// they exist. On success, it returns the digest correpsonding to this policy
// for the specified digest algorithm.
func (p *Policy) Validate(alg tpm2.HashAlgorithmId) (tpm2.Digest, error) {
	digest := &taggedHash{HashAlg: alg, Digest: make(tpm2.Digest, alg.Size())}

	runner := new(policyRunner)
	runner.policyRunnerContext = newValidatePolicyRunnerContext(runner, digest)
	if err := runner.run(p.policy.Policy); err != nil {
		return nil, err
	}

	//for _, d := range p.policy.PolicyDigests {
	//	if d.HashAlg != alg {
	//		continue
	//	}
	//
	//	if !bytes.Equal(d.Digest, digest.Digest) {
	//		return nil, fmt.Errorf("stored and computed policy digest mismatch (computed: %x, stored: %x)", digest.Digest, d.Digest)
	//	}
	//}

	return digest.Digest, nil
}

type introspectPolicyContext struct {
	completed         map[PolicyBranchPath]*PolicyBranchInformation
	enteredRootBranch bool
	currentInfo       PolicyBranchInformation
	currentPath       PolicyBranchPath
}

func newIntrospectPolicyContext() *introspectPolicyContext {
	return &introspectPolicyContext{
		completed: make(map[PolicyBranchPath]*PolicyBranchInformation),
	}
}

type introspectPolicySessionContext struct {
	context *introspectPolicyContext
}

func newIntrospectPolicySessionContext(context *introspectPolicyContext) *introspectPolicySessionContext {
	return &introspectPolicySessionContext{context: context}
}

func (s *introspectPolicySessionContext) HashAlg() tpm2.HashAlgorithmId {
	return tpm2.HashAlgorithmNull
}

func (s *introspectPolicySessionContext) PolicyNV(auth, index tpm2.ResourceContext, operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp, authAuthSession tpm2.SessionContext) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicySecret(authObject tpm2.ResourceContext, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, authObjectAuthSession tpm2.SessionContext) (tpm2.Timeout, *tpm2.TkAuth, error) {
	s.context.currentInfo.Secrets = append(s.context.currentInfo.Secrets, PolicyAuthorizationID{
		AuthName:  authObject.Name(),
		PolicyRef: policyRef,
	})
	return nil, nil, nil
}

func (s *introspectPolicySessionContext) PolicySigned(authKey tpm2.ResourceContext, includeNonceTPM bool, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, auth *tpm2.Signature) (tpm2.Timeout, *tpm2.TkAuth, error) {
	s.context.currentInfo.Signed = append(s.context.currentInfo.Signed, PolicyAuthorizationID{
		AuthName:  authKey.Name(),
		PolicyRef: policyRef,
	})
	return nil, nil, nil
}

func (s *introspectPolicySessionContext) PolicyAuthorize(approvedPolicy tpm2.Digest, policyRef tpm2.Nonce, keySign tpm2.Name, verified *tpm2.TkVerified) error {
	s.context.currentInfo.Authorized = append(s.context.currentInfo.Authorized, PolicyAuthorizationID{
		AuthName:  keySign,
		PolicyRef: policyRef,
	})
	return nil
}

func (s *introspectPolicySessionContext) PolicyAuthValue() error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyCommandCode(code tpm2.CommandCode) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyCounterTimer(operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyCpHash(cpHashA tpm2.Digest) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyNameHash(nameHash tpm2.Digest) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyOR(pHashList tpm2.DigestList) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyTicket(timeout tpm2.Timeout, cpHashA tpm2.Digest, policyRef tpm2.Nonce, authName tpm2.Name, ticket *tpm2.TkAuth) error {
	panic("not reached")
}

func (s *introspectPolicySessionContext) PolicyPCR(pcrDigest tpm2.Digest, pcrs tpm2.PCRSelectionList) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyDuplicationSelect(objectName, newParentName tpm2.Name, includeObject bool) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyPassword() error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyNvWritten(writtenSet bool) error {
	return nil
}

func (s *introspectPolicySessionContext) PolicyGetDigest() (tpm2.Digest, error) {
	return nil, nil
}

type introspectPolicyBranchNodeContext struct {
	path PolicyBranchPath
	info PolicyBranchInformation
}

type policyIntrospectRootBranch struct {
	context    *introspectPolicyContext
	elements   policyElements
	dispatcher policyRunDispatcher
}

func (*policyIntrospectRootBranch) name() string { return "introspect root policy branch" }

func (e *policyIntrospectRootBranch) run(context policySessionContext) error {
	var elements []policyElementRunner
	for _, element := range e.elements {
		elements = append(elements, element)
	}
	elements = append(elements, &policyIntrospectCommitBranch{context: e.context})

	e.dispatcher.runElementsNext(elements)
	return nil
}

type policyIntrospectBranch struct {
	context     *introspectPolicyContext
	nodeContext *introspectPolicyBranchNodeContext
	branchIndex int
	branch      *policyBranch
	remaining   []policyElementRunner
	dispatcher  policyRunDispatcher
}

func (*policyIntrospectBranch) name() string { return "introspect policy branch" }

func (e *policyIntrospectBranch) run(context policySessionContext) error {
	var pathElements []string
	if e.nodeContext.path != "" {
		pathElements = append(pathElements, string(e.nodeContext.path))
	}
	name := e.branch.Name
	if name == "" {
		name = PolicyBranchName(fmt.Sprintf("$[%d]", e.branchIndex))
	}
	pathElements = append(pathElements, string(name))
	e.context.currentPath = PolicyBranchPath(strings.Join(pathElements, "/"))
	e.context.currentInfo = e.nodeContext.info

	var elements []policyElementRunner
	for _, element := range e.branch.Policy {
		elements = append(elements, element)
	}
	elements = append(elements, e.remaining...)

	e.dispatcher.runElementsNext(elements)
	return nil
}

type policyIntrospectCommitBranch struct {
	context *introspectPolicyContext
}

func (*policyIntrospectCommitBranch) name() string { return "introspect policy branch commit" }

func (e *policyIntrospectCommitBranch) run(context policySessionContext) error {
	info := e.context.currentInfo
	e.context.completed[e.context.currentPath] = &info
	return nil
}

type introspectPolicyFlowHandler struct {
	context *introspectPolicyContext
	runner  *policyRunner
}

func newIntrospectPolicyFlowHandler(context *introspectPolicyContext, runner *policyRunner) *introspectPolicyFlowHandler {
	return &introspectPolicyFlowHandler{
		context: context,
		runner:  runner,
	}
}

func (h *introspectPolicyFlowHandler) handleBranches(branches policyBranches) error {
	if !h.context.enteredRootBranch {
		if len(branches) != 1 || len(h.runner.elements) > 0 {
			panic("unexpected error")
		}
		h.runner.elements = []policyElementRunner{
			&policyIntrospectRootBranch{
				context:    h.context,
				elements:   branches[0].Policy,
				dispatcher: h.runner,
			},
		}
		h.context.enteredRootBranch = true
		return nil
	}

	nodeContext := &introspectPolicyBranchNodeContext{
		path: h.context.currentPath,
		info: h.context.currentInfo,
	}

	var elements []policyElementRunner
	for i, branch := range branches {
		branch := branch
		elements = append(elements, &policyIntrospectBranch{
			context:     h.context,
			nodeContext: nodeContext,
			branch:      &branch,
			branchIndex: i,
			remaining:   h.runner.elements,
			dispatcher:  h.runner,
		})
	}

	h.runner.elements = elements
	return nil
}

func (h *introspectPolicyFlowHandler) pushComputeContext(digest *taggedHash) {}

func newIntrospectPolicyRunnerContext(runner *policyRunner, context *introspectPolicyContext) *policyRunnerContext {
	external := make(map[*tpm2.Public]tpm2.Name)
	return newPolicyRunnerContext(
		newIntrospectPolicySessionContext(context),
		newMockPolicyParams(external),
		newOfflinePolicyResources(external),
		newIntrospectPolicyFlowHandler(context, runner),
	)
}

// PolicyAuthorizationID identifies a policy authorization.
type PolicyAuthorizationID struct {
	AuthName  tpm2.Name
	PolicyRef tpm2.Nonce
}

// PolicyBranchInformation contains information associated with a branch
// in a policy.
type PolicyBranchInformation struct {
	Secrets    []PolicyAuthorizationID // TPM2_PolicySecret assetions
	Signed     []PolicyAuthorizationID // TPM2_PolicySigned assertions
	Authorized []PolicyAuthorizationID // TPM2_PolicyAuthorize assertions
}

// PolicyInformation contains information about a policy, keyed by branch
// path.
type PolicyInformation struct {
	branches map[PolicyBranchPath]*PolicyBranchInformation
}

// Branches returns a sorted list of paths in this policy.
func (i *PolicyInformation) Branches() []PolicyBranchPath {
	var paths []string
	for k := range i.branches {
		paths = append(paths, string(k))
	}
	sort.Strings(paths)

	var out []PolicyBranchPath
	for _, path := range paths {
		out = append(out, PolicyBranchPath(path))
	}
	return out
}

// BranchInformation returns the information associated with a specific branch path.
func (i *PolicyInformation) BranchInformation(path PolicyBranchPath) *PolicyBranchInformation {
	return i.branches[path]
}

// Introspect returns information about a policy.
func (p *Policy) Introspect() (*PolicyInformation, error) {
	context := newIntrospectPolicyContext()

	runner := new(policyRunner)
	runner.policyRunnerContext = newIntrospectPolicyRunnerContext(runner, context)

	root := &policyElement{
		Type: commandPolicyBranchNode,
		Details: &policyElementDetails{
			BranchNode: &policyBranchNode{
				Branches: policyBranches{{Policy: p.policy.Policy}},
			},
		},
	}
	if err := runner.run(policyElements{root}); err != nil {
		return nil, err
	}

	return &PolicyInformation{
		branches: context.completed,
	}, nil
}
